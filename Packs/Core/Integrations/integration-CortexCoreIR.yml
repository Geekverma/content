category: Endpoint
commonfields:
  id: Cortex Core - IR
  version: -1
configuration:
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Server URL (copy URL from Core - click ? to see more info.)
  name: url
  required: false
  type: 0
- display: API Key ID
  name: apikey_id
  required: false
  type: 4
- display: API Key
  name: apikey
  required: false
  type: 4
- additionalinfo: The timeout of the HTTP requests sent to Cortex XDR API (in seconds).
  defaultvalue: '120'
  display: HTTP Timeout
  name: timeout
  required: false
  type: 0
- additionalinfo: For Cortex XSOAR version 6.0.0 and above. If selected, for every incident fetched from Cortex XDR to Cortex XSOAR, the incident owners will be synced. Note that once this value is changed and synchronized between the systems, additional changes will not be reflected. For example, if you change the owner in Cortex XSOAR, the new owner will also be changed in Cortex XDR. However, if you now change the owner back in Cortex XDR, this additional change will not be reflected in Cortex XSOAR. In addition, for this change to be reflected, the owners must exist in both Cortex XSOAR and Cortex XDR.
  display: Sync Incident Owners
  hidden: false
  name: sync_owners
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Cortex XDR is the world's first detection and response app that natively integrates network, endpoint, and cloud data to stop sophisticated attacks.
display: Investigation & Response
name: Cortex Core - IR
script:
  commands:
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: The endpoint ID (string) to isolate. You can retrieve the string from the core-get-endpoints command.
      isArray: false
      name: endpoint_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Whether to suppress an error when trying to isolate a disconnected endpoint. When sets to false, an error will be returned.
      isArray: false
      name: suppress_disconnected_endpoint_error
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Isolates the specified endpoint.
    execution: true
    name: core-isolate-endpoint
    polling: true
    outputs:
    - contextPath: Core.Isolation.endpoint_id
      description: The endpoint ID.
      type: String
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: The endpoint ID (string) for which to reverse the isolation. You can retrieve it from the core-get-endpoints command.
      isArray: false
      name: endpoint_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Whether to suppress an error when trying to unisolate a disconnected endpoint. When sets to false, an error will be returned.
      isArray: false
      name: suppress_disconnected_endpoint_error
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Reverses the isolation of an endpoint.
    execution: true
    name: core-unisolate-endpoint
    polling: true
    outputs:
    - contextPath: Core.UnIsolation.endpoint_id
      description: Isolates the specified endpoint.
      type: String
  - arguments:
    - default: false
      description: A comma-separated list of endpoint IDs.
      isArray: true
      name: endpoint_id_list
      required: false
      secret: false
    - default: false
      description: "A comma-separated list of distribution package names or installation package names. \nExample: dist_name1,dist_name2"
      isArray: true
      name: dist_name
      required: false
      secret: false
    - default: false
      description: |-
        A comma-separated list of IP addresses.
        Example: 8.8.8.8,1.1.1.1
      isArray: true
      name: ip_list
      required: false
      secret: false
    - default: false
      description: |-
        The group name to which the agent belongs.
        Example: group_name1,group_name2
      isArray: true
      name: group_name
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: 'The endpoint platform. Valid values are\: "windows", "linux", "macos", or "android". '
      isArray: true
      name: platform
      predefined:
      - windows
      - linux
      - macos
      - android
      required: false
      secret: false
    - default: false
      description: |-
        A comma-separated list of alias names.
        Examples: alias_name1,alias_name2
      isArray: true
      name: alias_name
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specifies whether the endpoint was isolated or unisolated.
      isArray: false
      name: isolate
      predefined:
      - isolated
      - unisolated
      required: false
      secret: false
    - default: false
      description: |-
        Hostname
        Example: hostname1,hostname2
      isArray: true
      name: hostname
      required: false
      secret: false
    - default: false
      description: |-
        All the agents that were first seen after {first_seen_gte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: first_seen_gte
      required: false
      secret: false
    - default: false
      description: |-
        All the agents that were first seen before {first_seen_lte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: first_seen_lte
      required: false
      secret: false
    - default: false
      description: |-
        All the agents that were last seen before {last_seen_gte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: last_seen_gte
      required: false
      secret: false
    - default: false
      description: |-
        All the agents that were last seen before {last_seen_lte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: last_seen_lte
      required: false
      secret: false
    - default: false
      defaultValue: '0'
      description: Page number (for pagination). The default is 0 (the first page).
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '30'
      description: Maximum number of endpoints to return per page. The default and maximum is 30.
      isArray: false
      name: limit
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specifies whether to sort endpoints by the first time or last time they were seen. Can be "first_seen" or "last_seen".
      isArray: false
      name: sort_by
      predefined:
      - first_seen
      - last_seen
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: asc
      description: The order by which to sort results. Can be "asc" (ascending) or "desc" ( descending). Default set to asc.
      isArray: false
      name: sort_order
      predefined:
      - asc
      - desc
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The status of the endpoint to filter.
      isArray: false
      name: status
      predefined:
      - connected
      - disconnected
      - lost
      - uninstalled
      required: false
      secret: false
    deprecated: false
    description: Gets a list of endpoints, according to the passed filters. If there are no filters, all endpoints are returned. Filtering by multiple fields will be concatenated using AND condition (OR is not supported). Maximum result set size is 100. Offset is the zero-based number of endpoint from the start of the result set (start by counting from 0).
    execution: false
    name: core-get-endpoints
    outputs:
    - contextPath: Core.Endpoint.endpoint_id
      description: The endpoint ID.
      type: String
    - contextPath: Core.Endpoint.endpoint_name
      description: The endpoint name.
      type: String
    - contextPath: Core.Endpoint.endpoint_type
      description: The endpoint type.
      type: String
    - contextPath: Core.Endpoint.endpoint_status
      description: The status of the endpoint.
      type: String
    - contextPath: Core.Endpoint.os_type
      description: The endpoint OS type.
      type: String
    - contextPath: Core.Endpoint.ip
      description: A list of IP addresses.
      type: Unknown
    - contextPath: Core.Endpoint.users
      description: A list of users.
      type: Unknown
    - contextPath: Core.Endpoint.domain
      description: The endpoint domain.
      type: String
    - contextPath: Core.Endpoint.alias
      description: The endpoint's aliases.
      type: String
    - contextPath: Core.Endpoint.first_seen
      description: First seen date/time in Epoch (milliseconds).
      type: Unknown
    - contextPath: Core.Endpoint.last_seen
      description: Last seen date/time in Epoch (milliseconds).
      type: Date
    - contextPath: Core.Endpoint.content_version
      description: Content version.
      type: String
    - contextPath: Core.Endpoint.installation_package
      description: Installation package.
      type: String
    - contextPath: Core.Endpoint.active_directory
      description: Active directory.
      type: String
    - contextPath: Core.Endpoint.install_date
      description: Install date in Epoch (milliseconds).
      type: Date
    - contextPath: Core.Endpoint.endpoint_version
      description: Endpoint version.
      type: String
    - contextPath: Core.Endpoint.is_isolated
      description: Whether the endpoint is isolated.
      type: String
    - contextPath: Core.Endpoint.group_name
      description: The name of the group to which the endpoint belongs.
      type: String
    - contextPath: Endpoint.Hostname
      description: The hostname that is mapped to this endpoint.
      type: String
    - contextPath: Endpoint.ID
      description: The unique ID within the tool retrieving the endpoint.
      type: String
    - contextPath: Endpoint.IPAddress
      description: The IP address of the endpoint.
      type: String
    - contextPath: Endpoint.Domain
      description: The domain of the endpoint.
      type: String
    - contextPath: Endpoint.OS
      description: The endpoint's operation system.
      type: String
    - contextPath: Account.Username
      description: The username in the relevant system.
      type: String
    - contextPath: Account.Domain
      description: The domain of the account.
      type: String
    - contextPath: Endpoint.Status
      description: The endpoint's status.
      type: String
    - contextPath: Endpoint.IsIsolated
      description: The endpoint's isolation status.
      type: String
    - contextPath: Endpoint.MACAddress
      description: The endpoint's MAC address.
      type: String
    - contextPath: Endpoint.Vendor
      description: The integration name of the endpoint vendor.
      type: String
  - deprecated: false
    description: Gets a list of all the agent versions to use for creating a distribution list.
    execution: false
    name: core-get-distribution-versions
    outputs:
    - contextPath: Core.DistributionVersions.windows
      description: A list of Windows agent versions.
      type: Unknown
    - contextPath: Core.DistributionVersions.linux
      description: A list of Linux agent versions.
      type: Unknown
    - contextPath: Core.DistributionVersions.macos
      description: A list of Mac agent versions.
      type: Unknown
  - arguments:
    - default: false
      description: A string representing the name of the installation package.
      isArray: false
      name: name
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: "String, valid values are:\n• windows \n• linux\n• macos \n• android"
      isArray: false
      name: platform
      predefined:
      - windows
      - linux
      - macos
      - android
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: |-
        A string representing the type of package to create.
        standalone - An installation for a new agent
        upgrade - An upgrade of an agent from ESM
      isArray: false
      name: package_type
      predefined:
      - standalone
      - upgrade
      required: true
      secret: false
    - default: false
      description: agent_version returned from core-get-distribution-versions. Not required for Android platfom
      isArray: false
      name: agent_version
      required: true
      secret: false
    - default: false
      description: Information about the package.
      isArray: false
      name: description
      required: false
      secret: false
    deprecated: false
    description: Creates an installation package. This is an asynchronous call that returns the distribution ID. This does not mean that the creation succeeded. To confirm that the package has been created, check the status of the distribution by running the Get Distribution Status API.
    execution: false
    name: core-create-distribution
    outputs:
    - contextPath: Core.Distribution.id
      description: The installation package ID.
      type: String
    - contextPath: Core.Distribution.name
      description: The name of the installation package.
      type: String
    - contextPath: Core.Distribution.platform
      description: The installation OS.
      type: String
    - contextPath: Core.Distribution.agent_version
      description: Agent version.
      type: String
    - contextPath: Core.Distribution.description
      description: Information about the package.
      type: String
  - arguments:
    - default: false
      description: |-
        The ID of the installation package.
        Copy the distribution_id from the "id" field on Endpoints > Agent Installation page.
      isArray: false
      name: distribution_id
      required: true
      secret: false
    - auto: PREDEFINED
      default: false
      description: |-
        The installation package type. Valid
        values are:
        • upgrade
        • sh - For Linux
        • rpm - For Linux
        • deb - For Linux
        • pkg - For Mac
        • x86 - For Windows
        • x64 - For Windows
      isArray: false
      name: package_type
      predefined:
      - upgrade
      - sh
      - rpm
      - deb
      - pkg
      - x86
      - x64
      required: true
      secret: false
    deprecated: false
    description: Gets the distribution URL for downloading the installation package.
    execution: false
    name: core-get-distribution-url
    outputs:
    - contextPath: Core.Distribution.id
      description: Distribution ID.
      type: String
    - contextPath: Core.Distribution.url
      description: URL for downloading the installation package.
      type: String
  - arguments:
    - default: false
      description: A comma-separated list of distribution IDs to get the status of.
      isArray: true
      name: distribution_ids
      required: true
      secret: false
    deprecated: false
    description: Gets the status of the installation package.
    execution: false
    name: core-get-create-distribution-status
    outputs:
    - contextPath: Core.Distribution.id
      description: Distribution ID.
      type: String
    - contextPath: Core.Distribution.status
      description: The status of installation package.
      type: String
  - arguments:
    - default: false
      description: User’s email address.
      isArray: false
      name: email
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The audit log type.
      isArray: false
      name: type
      predefined:
      - REMOTE_TERMINAL
      - RULES
      - AUTH
      - RESPONSE
      - INCIDENT_MANAGEMENT
      - ENDPOINT_MANAGEMENT
      - ALERT_WHITELIST
      - PUBLIC_API
      - DISTRIBUTIONS
      - STARRED_INCIDENTS
      - POLICY_PROFILES
      - DEVICE_CONTROL_PROFILE
      - HOST_FIREWALL_PROFILE
      - POLICY_RULES
      - PROTECTION_POLICY
      - DEVICE_CONTROL_TEMP_EXCEPTIONS
      - DEVICE_CONTROL_GLOBAL_EXCEPTIONS
      - GLOBAL_EXCEPTIONS
      - MSSP
      - REPORTING
      - DASHBOARD
      - BROKER_VM
      required: false
      secret: false
    - default: false
      description: The audit log subtype.
      isArray: false
      name: sub_type
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Result type
      isArray: false
      name: result
      predefined:
      - SUCCESS
      - FAIL
      - PARTIAL
      required: false
      secret: false
    - default: false
      description: |-
        Return logs for which the timestamp is after 'log_time_after'.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: timestamp_gte
      required: false
      secret: false
    - default: false
      description: |-
        Return logs for which the timestamp is before the 'log_time_after'.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: timestamp_lte
      required: false
      secret: false
    - default: false
      defaultValue: '0'
      description: Page number (for pagination). The default is 0 (the first page).
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '30'
      description: Maximum number of audit logs to return per page. The default and maximum is 30.
      isArray: false
      name: limit
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Specifies the field by which to sort the results. By default the sort is defined as creation-time and DESC. Can be "type", "sub_type", "result", or "timestamp".
      isArray: false
      name: sort_by
      predefined:
      - type
      - sub_type
      - result
      - timestamp
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: desc
      description: The sort order. Can be "asc" (ascending) or "desc" (descending). Default set to "desc".
      isArray: false
      name: sort_order
      predefined:
      - asc
      - desc
      required: false
      secret: false
    deprecated: false
    description: Gets management logs. You can filter by multiple fields, which will be concatenated using the AND condition (OR is not supported). Maximum result set size is 100. Offset is the zero-based number of management logs from the start of the result set (start by counting from 0).
    execution: false
    name: core-get-audit-management-logs
    outputs:
    - contextPath: Core.AuditManagementLogs.AUDIT_ID
      description: Audit log ID.
      type: Number
    - contextPath: Core.AuditManagementLogs.AUDIT_OWNER_NAME
      description: Audit owner name.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_OWNER_EMAIL
      description: Audit owner email address.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_ASSET_JSON
      description: Asset JSON.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_ASSET_NAMES
      description: Audit asset names.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_HOSTNAME
      description: Host name.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_RESULT
      description: Audit result.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_REASON
      description: Audit reason.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_DESCRIPTION
      description: Description of the audit.
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_ENTITY
      description: Audit entity (e.g., AUTH, DISTRIBUTIONS).
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_ENTITY_SUBTYPE
      description: Entity subtype (e.g., Login, Create).
      type: String
    - contextPath: Core.AuditManagementLogs.AUDIT_CASE_ID
      description: Audit case ID.
      type: Number
    - contextPath: Core.AuditManagementLogs.AUDIT_INSERT_TIME
      description: Log's insert time.
      type: Date
  - arguments:
    - default: false
      description: A comma-separated list of endpoint IDs.
      isArray: true
      name: endpoint_ids
      required: false
      secret: false
    - default: false
      description: A comma-separated list of endpoint names.
      isArray: true
      name: endpoint_names
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The report type. Can be "Installation", "Policy", "Action", "Agent Service", "Agent Modules", or "Agent Status".
      isArray: true
      name: type
      predefined:
      - Installation
      - Policy
      - Action
      - Agent Service
      - Agent Modules
      - Agent Status
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The report subtype.
      isArray: true
      name: sub_type
      predefined:
      - Install
      - Uninstall
      - Upgrade
      - Local Configuration
      - Content Update
      - Policy Update
      - Process Exception
      - Hash Exception
      - Scan
      - File Retrieval
      - File Scan
      - Terminate Process
      - Isolate
      - Cancel Isolation
      - Payload Execution
      - Quarantine
      - Restore
      - Stop
      - Start
      - Module Initialization
      - Local Analysis Model
      - Local Analysis Feature Extraction
      - Fully Protected
      - OS Incompatible
      - Software Incompatible
      - Kernel Driver Initialization
      - Kernel Extension Initialization
      - Proxy Communication
      - Quota Exceeded
      - Minimal Content
      - Reboot Eequired
      - Missing Disc Access
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The result type. Can be "Success" or "Fail". If not passed, returns all event reports.
      isArray: true
      name: result
      predefined:
      - Success
      - Fail
      required: false
      secret: false
    - default: false
      description: |-
        Return logs that their timestamp is greater than 'log_time_after'.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: timestamp_gte
      required: false
      secret: false
    - default: false
      description: |-
        Return logs for which the timestamp is before the 'timestamp_lte'.

        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      isArray: false
      name: timestamp_lte
      required: false
      secret: false
    - default: false
      defaultValue: '0'
      description: Page number (for pagination). The default is 0 (the first page).
      isArray: false
      name: page
      required: false
      secret: false
    - default: false
      defaultValue: '30'
      description: The maximum number of reports to return. Default and maximum is 30.
      isArray: false
      name: limit
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: The field by which to sort results. Can be "type", "category", "trapsversion", "timestamp", or "domain").
      isArray: false
      name: sort_by
      predefined:
      - type
      - category
      - trapsversion
      - timestamp
      - domain
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: asc
      description: The sort order. Can be "asc" (ascending) or "desc" (descending). Default is "asc".
      isArray: false
      name: sort_order
      predefined:
      - asc
      - desc
      required: false
      secret: false
    deprecated: false
    description: Gets agent event reports. You can filter by multiple fields, which will be concatenated using the AND condition (OR is not supported). Maximum result set size is 100. Offset is the zero-based number of reports from the start of the result set (start by counting from 0).
    execution: false
    name: core-get-audit-agent-reports
    outputs:
    - contextPath: Core.AuditAgentReports.ENDPOINTID
      description: Endpoint ID.
      type: String
    - contextPath: Core.AuditAgentReports.ENDPOINTNAME
      description: Endpoint name.
      type: String
    - contextPath: Core.AuditAgentReports.DOMAIN
      description: Agent domain.
      type: String
    - contextPath: Core.AuditAgentReports.TRAPSVERSION
      description: Traps version.
      type: String
    - contextPath: Core.AuditAgentReports.RECEIVEDTIME
      description: Received time in Epoch time.
      type: Date
    - contextPath: Core.AuditAgentReports.TIMESTAMP
      description: Timestamp in Epoch time.
      type: Date
    - contextPath: Core.AuditAgentReports.CATEGORY
      description: Report category (e.g., Audit).
      type: String
    - contextPath: Core.AuditAgentReports.TYPE
      description: Report type (e.g., Action, Policy).
      type: String
    - contextPath: Core.AuditAgentReports.SUBTYPE
      description: Report subtype (e.g., Fully Protected,Policy Update,Cancel Isolation).
      type: String
    - contextPath: Core.AuditAgentReports.RESULT
      description: Report result.
      type: String
    - contextPath: Core.AuditAgentReports.REASON
      description: Report reason.
      type: String
    - contextPath: Core.AuditAgentReports.DESCRIPTION
      description: Agent report description.
      type: String
    - contextPath: Endpoint.ID
      description: The unique ID within the tool retrieving the endpoint.
      type: String
    - contextPath: Endpoint.Hostname
      description: The hostname that is mapped to this endpoint.
      type: String
    - contextPath: Endpoint.Domain
      description: The domain of the endpoint.
      type: String
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: String that represents a list of hashed files you want to block list. Must be a valid SHA256 hash.
      isArray: true
      name: hash_list
      required: true
      secret: false
    - default: false
      description: String that represents additional information regarding the action.
      isArray: false
      name: comment
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Whether to response detailed response. default value = false
      isArray: false
      name: detailed_response
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Block lists requested files which have not already been block listed or added to allow list.
    execution: false
    name: core-blocklist-files
    outputs:
    - contextPath: Core.blocklist.added_hashes
      description: Added fileHash to blocklist
      type: Number
    - contextPath: Core.blocklist.excluded_hashes
      description: Added fileHash to blocklist
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: String that represents a list of hashed files you want to add to allow list. Must be a valid SHA256 hash.
      isArray: true
      name: hash_list
      required: true
      secret: false
    - default: false
      description: String that represents additional information regarding the action.
      isArray: false
      name: comment
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Whether to response detailed response. default value = false
      isArray: false
      name: detailed_response
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Adds requested files to allow list if they are not already on block list or allow list.
    execution: false
    name: core-allowlist-files
    outputs:
    - contextPath: Core.allowlist.added_hashes
      description: Added fileHash to allowlist
      type: Number
    - contextPath: Core.allowlist.excluded_hashes
      description: Added fileHash to allowlist
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: List of endpoint IDs.
      isArray: true
      name: endpoint_id_list
      required: true
      secret: false
    - default: false
      description: String that represents the path of the file you want to quarantine.
      isArray: false
      name: file_path
      required: true
      secret: false
    - default: false
      description: String that represents the file’s hash. Must be a valid SHA256 hash.
      isArray: false
      name: file_hash
      required: true
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Quarantines a file on selected endpoints. You can select up to 1000 endpoints.
    execution: false
    name: core-quarantine-files
    polling: true
  - arguments:
    - default: false
      description: String the represents the endpoint ID.
      isArray: false
      name: endpoint_id
      required: true
      secret: false
    - default: false
      description: String that represents the file hash. Must be a valid SHA256 hash.
      isArray: false
      name: file_hash
      required: true
      secret: false
    - default: false
      description: String that represents the file path.
      isArray: false
      name: file_path
      required: true
      secret: false
    deprecated: false
    description: Retrieves the quarantine status for a selected file.
    execution: false
    name: core-get-quarantine-status
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: String that represents the file in hash. Must be a valid SHA256 hash.
      isArray: false
      name: file_hash
      required: true
      secret: false
    - default: false
      description: String that represents the endpoint ID. If you do not enter a specific endpoint ID, the request will run restore on all endpoints which relate to the quarantined file you defined.
      isArray: false
      name: endpoint_id
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Restores a quarantined file on requested endpoints.
    execution: false
    name: core-restore-file
    polling: true
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: List of endpoint IDs.
      isArray: true
      name: endpoint_id_list
      required: false
      secret: false
    - default: false
      description: Name of the distribution list.
      isArray: true
      name: dist_name
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: gte_first_seen
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: gte_last_seen
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: lte_first_seen
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: lte_last_seen
      required: false
      secret: false
    - default: false
      description: List of IP addresses.
      isArray: true
      name: ip_list
      required: false
      secret: false
    - default: false
      description: Name of the endpoint group.
      isArray: true
      name: group_name
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Type of operating system.
      isArray: true
      name: platform
      predefined:
      - windows
      - linux
      - macos
      - android
      required: false
      secret: false
    - default: false
      description: Endpoint alias name.
      isArray: true
      name: alias
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Whether an endpoint has been isolated. Can be "isolated" or "unisolated".
      isArray: false
      name: isolate
      predefined:
      - isolated
      - unisolated
      required: false
      secret: false
    - default: false
      description: Name of the host.
      isArray: true
      name: hostname
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Whether to scan all of the endpoints or not. Default is false. Scanning all of the endpoints may cause performance issues and latency.
      isArray: false
      name: all
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Runs a scan on a selected endpoint. To scan all endpoints, run this command with argument all=true. Do note that scanning all the endpoints may cause performance issues and latency.
    execution: true
    name: core-endpoint-scan
    polling: true
    outputs:
    - contextPath: Core.endpointScan.actionId
      description: The action ID of the scan request.
      type: Number
    - contextPath: Core.endpointScan.aborted
      description: Was the scan aborted.
      type: Boolean
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: List of endpoint IDs.
      isArray: true
      name: endpoint_id_list
      required: false
      secret: false
    - default: false
      description: Name of the distribution list.
      isArray: true
      name: dist_name
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: gte_first_seen
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: gte_last_seen
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: lte_first_seen
      required: false
      secret: false
    - default: false
      description: Epoch timestamp in milliseconds.
      isArray: false
      name: lte_last_seen
      required: false
      secret: false
    - default: false
      description: List of IP addresses.
      isArray: true
      name: ip_list
      required: false
      secret: false
    - default: false
      description: Name of the endpoint group.
      isArray: true
      name: group_name
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Type of operating system.
      isArray: true
      name: platform
      predefined:
      - windows
      - linux
      - macos
      - android
      required: false
      secret: false
    - default: false
      description: Endpoint alias name.
      isArray: true
      name: alias
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Whether an endpoint has been isolated. Can be "isolated" or "unisolated".
      isArray: false
      name: isolate
      predefined:
      - isolated
      - unisolated
      required: false
      secret: false
    - default: false
      description: Name of the host.
      isArray: true
      name: hostname
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'false'
      description: Whether to scan all of the endpoints or not. Default is false. Note that scanning all of the endpoints may cause performance issues and latency.
      isArray: false
      name: all
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Cancel the scan of selected endpoints. A scan can only be aborted if the selected endpoints are Pending or In Progress. To scan all endpoints, run the command with the argument all=true. Note that scanning all of the endpoints may cause performance issues and latency.
    execution: true
    name: core-endpoint-scan-abort
    outputs:
    - contextPath: Core.endpointScan.actionId
      description: The action id of the abort scan request.
      type: Unknown
    - contextPath: Core.endpointScan.aborted
      description: Was the scan aborted.
      type: Boolean
  - arguments:
    - default: false
      description: The endpoint ID. Can be retrieved by running the core-get-endpoints command.
      isArray: false
      name: endpoint_id
      required: true
      secret: false
    deprecated: false
    description: Gets the policy name for a specific endpoint.
    execution: false
    name: core-get-policy
    outputs:
    - contextPath: Core.Policy
      description: The policy allocated with the endpoint.
      type: string
    - contextPath: Core.Policy.policy_name
      description: Name of the policy allocated with the endpoint.
      type: string
    - contextPath: Core.Policy.endpoint_id
      description: Endpoint ID.
      type: string
  - arguments:
    - default: false
      description: A comma-separated list of the script names.
      isArray: true
      name: script_name
      required: false
      secret: false
    - default: false
      description: A comma-separated list of the script descriptions.
      isArray: true
      name: description
      required: false
      secret: false
    - default: false
      description: A comma-separated list of the users who created the script.
      isArray: true
      name: created_by
      required: false
      secret: false
    - default: false
      description: The maximum number of scripts returned to the War Room. Default is 50.
      isArray: false
      name: limit
      required: false
      secret: false
    - default: false
      description: (Int) Offset in the data set. Default is 0.
      isArray: false
      name: offset
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Whether the script can be executed on a Windows operating system.
      isArray: false
      name: windows_supported
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Whether the script can be executed on a Linux operating system.
      isArray: false
      name: linux_supported
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Whether the script can be executed on a Mac operating system.
      isArray: false
      name: macos_supported
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: Whether the script has a high-risk outcome.
      isArray: false
      name: is_high_risk
      predefined:
      - 'true'
      - 'false'
      required: false
      secret: false
    deprecated: false
    description: Gets a list of scripts available in the scripts library.
    execution: false
    name: core-get-scripts
    outputs:
    - contextPath: Core.Scripts
      description: The scripts command results.
      type: Unknown
    - contextPath: Core.Scripts.script_id
      description: Script ID.
      type: Unknown
    - contextPath: Core.Scripts.name
      description: Name of the script.
      type: string
    - contextPath: Core.Scripts.description
      description: Description of the script.
      type: string
    - contextPath: Core.Scripts.modification_date
      description: Timestamp of when the script was last modified.
      type: Unknown
    - contextPath: Core.Scripts.created_by
      description: Name of the user who created the script.
      type: string
    - contextPath: Core.Scripts.windows_supported
      description: Whether the script can be executed on a Windows operating system.
      type: boolean
    - contextPath: Core.Scripts.linux_supported
      description: Whether the script can be executed on a Linux operating system.
      type: boolean
    - contextPath: Core.Scripts.macos_supported
      description: Whether the script can be executed on Mac operating system.
      type: boolean
    - contextPath: Core.Scripts.is_high_risk
      description: Whether the script has a high-risk outcome.
      type: boolean
    - contextPath: Core.Scripts.script_uid
      description: Globally Unique Identifier of the script, used to identify the script when executing.
      type: string
  - arguments:
    - default: false
      description: Comma-separated list of endpoint IDs. You can retrieve the endpoint IDs from the core-get-endpoints command.
      isArray: false
      name: endpoint_ids
      required: true
      secret: false
    deprecated: false
    description: Deletes selected endpoints in the Cortex XDR app. You can delete up to 1000 endpoints.
    execution: false
    name: core-delete-endpoints
  - arguments:
    - default: false
      description: Comma-separated list of endpoint IDs. You can retrieve the endpoint IDs from the core-get-endpoints command.
      isArray: true
      name: endpoint_ids
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      description: 'Type of violation. Possible values are: "cd-rom", "disk drive", "floppy disk", and "portable device".'
      isArray: false
      name: type
      predefined:
      - cd-rom
      - disk drive
      - floppy disk
      - portable device
      required: false
      secret: false
    - default: false
      description: 'Timestamp of the violation. Violations that are greater than or equal to this timestamp will be returned. Values can be in either ISO date format, relative time, or epoch timestamp. For example:  "2019-10-21T23:45:00" (ISO date format), "3 days ago" (relative time) 1579039377301 (epoch time).'
      isArray: false
      name: timestamp_gte
      required: false
      secret: false
    - default: false
      description: 'Timestamp of the violation. Violations that are less than or equal to this timestamp will be returned. Values can be in either ISO date format, relative time, or epoch timestamp. For example:  "2019-10-21T23:45:00" (ISO date format), "3 days ago" (relative time) 1579039377301 (epoch time).'
      isArray: false
      name: timestamp_lte
      required: false
      secret: false
    - default: false
      description: Comma-separated list of IP addresses.
      isArray: true
      name: ip_list
      required: false
      secret: false
    - default: false
      description: Name of the vendor.
      isArray: true
      name: vendor
      required: false
      secret: false
    - default: false
      description: Vendor ID.
      isArray: true
      name: vendor_id
      required: false
      secret: false
    - default: false
      description: Name of the product.
      isArray: true
      name: product
      required: false
      secret: false
    - default: false
      description: Product ID.
      isArray: true
      name: product_id
      required: false
      secret: false
    - default: false
      description: Serial number.
      isArray: true
      name: serial
      required: false
      secret: false
    - default: false
      description: Hostname.
      isArray: true
      name: hostname
      required: false
      secret: false
    - default: false
      description: Comma-separated list of violation IDs.
      isArray: true
      name: violation_id_list
      required: false
      secret: false
    - default: false
      description: Username.
      isArray: true
      name: username
      required: false
      secret: false
    deprecated: false
    description: Gets a list of device control violations filtered by selected fields. You can retrieve up to 100 violations.
    execution: false
    name: core-get-endpoint-device-control-violations
    outputs:
    - contextPath: Core.EndpointViolations
      description: Endpoint violations command results.
      type: Unknown
    - contextPath: Core.EndpointViolations.violations
      description: A list of violations.
      type: Unknown
    - contextPath: Core.EndpointViolations.violations.os_type
      description: Type of the operating system.
      type: string
    - contextPath: Core.EndpointViolations.violations.hostname
      description: Hostname of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.username
      description: Username of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.ip
      description: IP address of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.timestamp
      description: Timestamp of the violation.
      type: number
    - contextPath: Core.EndpointViolations.violations.violation_id
      description: Violation ID.
      type: number
    - contextPath: Core.EndpointViolations.violations.type
      description: Type of violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.vendor_id
      description: Vendor ID of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.vendor
      description: Name of the vendor of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.product_id
      description: Product ID of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.product
      description: Name of the product of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.serial
      description: Serial number of the violation.
      type: string
    - contextPath: Core.EndpointViolations.violations.endpoint_id
      description: Endpoint ID of the violation.
      type: string
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Comma-separated list of endpoint IDs.
      isArray: true
      name: endpoint_ids
      required: true
      secret: false
    - default: false
      description: A comma-separated list of file paths on the Windows platform.
      isArray: true
      name: windows_file_paths
      required: false
      secret: false
    - default: false
      description: A comma-separated list of file paths on the Linux platform.
      isArray: true
      name: linux_file_paths
      required: false
      secret: false
    - default: false
      description: A comma-separated list of file paths on the Mac platform.
      isArray: true
      name: mac_file_paths
      required: false
      secret: false
    - default: false
      description: A comma-separated list of file paths in any platform. Can be used instead of the mac/windows/linux file paths. The order of the files path list must be parellel to the endpoints list order, therefore, the first file path in the list is related to the first endpoint and so on.
      isArray: true
      name: generic_file_path
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Retrieves files from selected endpoints. You can retrieve up to 20 files, from no more than 10 endpoints. At least one endpoint ID and one file path are necessary in order to run the command. After running this command, you can use the core-action-status-get command with returned action_id, to check the action status.
    execution: false
    name: core-retrieve-files
    polling: true
    outputs:
    - contextPath: Core.RetrievedFiles.action_id
      description: ID of the action to retrieve files from selected endpoints.
      type: string
  - arguments:
    - default: false
      description: Action ID retrieved from the core-retrieve-files command.
      isArray: true
      name: action_id
      required: true
      secret: false
    deprecated: false
    description: View the file retrieved by the core-retrieve-files command according to the action ID. Before running this command, you can use the core-action-status-get command to check if this action completed successfully.
    execution: false
    name: core-retrieve-file-details
    outputs:
    - contextPath: File
      description: The file details command results.
      type: Unknown
    - contextPath: File.Name
      description: The full file name (including the file extension).
      type: String
    - contextPath: File.EntryID
      description: The ID for locating the file in the War Room.
      type: String
    - contextPath: File.Size
      description: The size of the file in bytes.
      type: Number
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Extension
      description: 'The file extension. For example: "xls".'
      type: String
    - contextPath: File.Type
      description: The file type, as determined by libmagic (same as displayed in file entries).
      type: String
  - arguments:
    - default: false
      description: Unique identifier of the script, returned by the core-get-scripts command.
      isArray: false
      name: script_uid
      required: true
      secret: false
    deprecated: false
    description: Gets the full definition of a specific script in the scripts library.
    execution: false
    name: core-get-script-metadata
    outputs:
    - contextPath: Core.ScriptMetadata
      description: The script metadata command results.
      type: Unknown
    - contextPath: Core.ScriptMetadata.script_id
      description: Script ID.
      type: number
    - contextPath: Core.ScriptMetadata.name
      description: Script name.
      type: string
    - contextPath: Core.ScriptMetadata.description
      description: Script description.
      type: string
    - contextPath: Core.ScriptMetadata.modification_date
      description: Timestamp of when the script was last modified.
      type: unknown
    - contextPath: Core.ScriptMetadata.created_by
      description: Name of the user who created the script.
      type: string
    - contextPath: Core.ScriptMetadata.is_high_risk
      description: Whether the script has a high-risk outcome.
      type: boolean
    - contextPath: Core.ScriptMetadata.windows_supported
      description: Whether the script can be executed on a Windows operating system.
      type: boolean
    - contextPath: Core.ScriptMetadata.linux_supported
      description: Whether the script can be executed on a Linux operating system.
      type: boolean
    - contextPath: Core.ScriptMetadata.macos_supported
      description: Whether the script can be executed on a Mac operating system.
      type: boolean
    - contextPath: Core.ScriptMetadata.entry_point
      description: Name of the entry point selected for the script. An empty string indicates  the script defined as just run.
      type: string
    - contextPath: Core.ScriptMetadata.script_input
      description: Name and type for the specified entry point.
      type: string
    - contextPath: Core.ScriptMetadata.script_output_type
      description: Type of the output.
      type: string
    - contextPath: Core.ScriptMetadata.script_output_dictionary_definitions
      description: If the script_output_type is a dictionary, an array with friendly name, name, and type for each output.
      type: Unknown
  - arguments:
    - default: false
      description: Unique identifier of the script, returned by the core-get-scripts command.
      isArray: false
      name: script_uid
      required: true
      secret: false
    deprecated: false
    description: Gets the code of a specific script in the script library.
    execution: false
    name: core-get-script-code
    outputs:
    - contextPath: Core.ScriptCode
      description: The script code command results.
      type: Unknown
    - contextPath: Core.ScriptCode.code
      description: The code of a specific script in the script library.
      type: string
    - contextPath: Core.ScriptCode.script_uid
      description: Unique identifier of the script.
      type: string
  - arguments:
    - default: false
      description: The action ID of the selected request. After performing an action, you will receive an action ID.
      isArray: true
      name: action_id
      required: true
      secret: false
    deprecated: false
    description: Retrieves the status of the requested actions according to the action ID.
    execution: false
    name: core-action-status-get
    outputs:
    - contextPath: Core.GetActionStatus
      description: The action status command results.
      type: Unknown
    - contextPath: Core.GetActionStatus.endpoint_id
      description: Endpoint ID.
      type: string
    - contextPath: Core.GetActionStatus.status
      description: The status of the specific endpoint ID.
      type: string
    - contextPath: Core.GetActionStatus.action_id
      description: The specified action ID.
      type: number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Comma-separated list of endpoint IDs. Can be retrieved by running the core-get-endpoints command.
      isArray: false
      name: endpoint_ids
      required: true
      secret: false
    - default: false
      description: Unique identifier of the script. Can be retrieved by running the core-get-scripts command.
      isArray: false
      name: script_uid
      required: true
      secret: false
    - default: false
      description: Dictionary contains the parameter name as key and its value for this execution as the value. For example, {"param1":"param1_value","param2":"param2_value"}
      isArray: false
      name: parameters
      required: false
      secret: false
    - default: false
      defaultValue: '600'
      description: The timeout in seconds for this execution.
      isArray: false
      name: timeout
      required: false
      secret: false
    deprecated: false
    description: Initiates a new endpoint script execution action using a script from the script library.
    execution: false
    name: core-run-script
    outputs:
    - contextPath: Core.ScriptRun.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptRun.endpoints_count
      description: Number of endpoints the action was initiated on.
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Comma-separated list of endpoint IDs. Can be retrieved by running the core-get-endpoints command.
      isArray: false
      name: endpoint_ids
      required: true
      secret: false
    - default: false
      description: Section of a script you want to initiate on an endpoint (e.g., print("7")).
      isArray: false
      name: snippet_code
      required: true
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Initiates a new endpoint script execution action using the provided snippet code.
    execution: false
    name: core-run-snippet-code-script
    polling: true
    outputs:
    - contextPath: Core.ScriptRun.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptRun.endpoints_count
      description: Number of endpoints the action was initiated on.
      type: Number
  - arguments:
    - default: false
      description: Action IDs retrieved from the core-run-script command.
      isArray: true
      name: action_id
      required: true
      secret: false
    deprecated: false
    description: Retrieves the status of a script execution action.
    execution: false
    name: core-get-script-execution-status
    outputs:
    - contextPath: Core.ScriptStatus.general_status
      description: General status of the action, considering the status of all the endpoints.
      type: String
    - contextPath: Core.ScriptStatus.error_message
      description: Error message regarding permissions for running APIs or the action doesn’t exist.
      type: String
    - contextPath: Core.ScriptStatus.endpoints_timeout
      description: Number of endpoints in "timeout" status.
      type: Number
    - contextPath: Core.ScriptStatus.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_pending_abort
      description: Number of endpoints in "pending abort" status.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_pending
      description: Number of endpoints in "pending" status.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_in_progress
      description: Number of endpoints in "in progress" status.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_failed
      description: Number of endpoints in "failed" status.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_expired
      description: Number of endpoints in "expired" status.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_completed_successfully
      description: Number of endpoints in "completed successfully" status.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_canceled
      description: Number of endpoints in "canceled" status.
      type: Number
    - contextPath: Core.ScriptStatus.endpoints_aborted
      description: Number of endpoints in "aborted" status.
      type: Number
  - arguments:
    - default: false
      description: Action IDs retrieved from the core-run-script command.
      isArray: true
      name: action_id
      required: true
      secret: false
    deprecated: false
    description: Retrieve the results of a script execution action.
    execution: false
    name: core-get-script-execution-results
    outputs:
    - contextPath: Core.ScriptResult.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptResult.results.retrieved_files
      description: Number of successfully retrieved files.
      type: Number
    - contextPath: Core.ScriptResult.results.endpoint_ip_address
      description: Endpoint IP address.
      type: String
    - contextPath: Core.ScriptResult.results.endpoint_name
      description: Number of successfully retrieved files.
      type: String
    - contextPath: Core.ScriptResult.results.failed_files
      description: Number of files failed to retrieve.
      type: Number
    - contextPath: Core.ScriptResult.results.endpoint_status
      description: Endpoint status.
      type: String
    - contextPath: Core.ScriptResult.results.domain
      description: Domain to which the endpoint belongs.
      type: String
    - contextPath: Core.ScriptResult.results.endpoint_id
      description: Endpoint ID.
      type: String
    - contextPath: Core.ScriptResult.results.execution_status
      description: Execution status of this endpoint.
      type: String
    - contextPath: Core.ScriptResult.results.return_value
      description: Value returned by the script in case the type is not a dictionary.
      type: String
    - contextPath: Core.ScriptResult.results.standard_output
      description: The STDOUT and the STDERR logged by the script during the execution.
      type: String
    - contextPath: Core.ScriptResult.results.retention_date
      description: Timestamp in which the retrieved files will be deleted from the server.
      type: Date
  - arguments:
    - default: false
      description: Action ID retrieved from the core-run-script command.
      isArray: true
      name: action_id
      required: true
      secret: false
    - default: false
      description: Endpoint ID. Can be retrieved by running the core-get-endpoints command.
      isArray: true
      name: endpoint_id
      required: true
      secret: false
    deprecated: false
    description: Gets the files retrieved from a specific endpoint during a script execution.
    execution: false
    name: core-get-script-execution-result-files
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: File.EntryID
      description: EntryID of the file
      type: String
    - contextPath: File.Info
      description: Information about the file.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.Extension
      description: The extension of the file.
      type: String
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Comma-separated list of endpoint IDs. Can be retrieved by running the core-get-endpoints command.
      isArray: false
      name: endpoint_ids
      required: true
      secret: false
    - default: false
      description: Comma-separated list of shell commands to execute.
      isArray: false
      name: commands
      required: true
      secret: false
    - default: false
      defaultValue: '600'
      description: The timeout in seconds for this execution.
      isArray: false
      name: timeout
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Initiate a new endpoint script execution of shell commands.
    execution: false
    name: core-run-script-execute-commands
    polling: true
    outputs:
    - contextPath: Core.ScriptRun.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptRun.endpoints_count
      description: Number of endpoints the action was initiated on.
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Comma-separated list of endpoint IDs. Can be retrieved by running the core-get-endpoints command.
      isArray: true
      name: endpoint_ids
      required: true
      secret: false
    - default: false
      description: Paths of the files to delete, in a comma-separated list. Paths of the files to check for existence. All of the given file paths will run on all of the endpoints.
      isArray: true
      name: file_path
      required: true
      secret: false
    - default: false
      defaultValue: '600'
      description: The timeout in seconds for this execution.
      isArray: false
      name: timeout
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Initiates a new endpoint script execution to delete the specified file.
    execution: false
    name: core-run-script-delete-file
    polling: true
    outputs:
    - contextPath: Core.ScriptRun.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptRun.endpoints_count
      description: Number of endpoints the action was initiated on.
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Comma-separated list of endpoint IDs. Can be retrieved by running the core-get-endpoints command.
      isArray: true
      name: endpoint_ids
      required: true
      secret: false
    - default: false
      description: Paths of the files to check for existence, in a comma-separated list. All of the given file paths will run on all of the endpoints.
      isArray: true
      name: file_path
      required: true
      secret: false
    - default: false
      defaultValue: '600'
      description: The timeout in seconds for this execution.
      isArray: false
      name: timeout
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Initiates a new endpoint script execution to check if file exists.
    execution: false
    name: core-run-script-file-exists
    polling: true
    outputs:
    - contextPath: Core.ScriptRun.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptRun.endpoints_count
      description: Number of endpoints the action was initiated on.
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: Comma-separated list of endpoint IDs. Can be retrieved by running the core-get-endpoints command.
      isArray: true
      name: endpoint_ids
      required: true
      secret: false
    - default: false
      description: Names of processes to kill. Will kill all of the given processes on all of the endpoints.
      isArray: true
      name: process_name
      required: true
      secret: false
    - default: false
      defaultValue: '600'
      description: The timeout in seconds for this execution.
      isArray: false
      name: timeout
      required: false
      secret: false
    - default: false
      description: For polling use
      isArray: true
      name: action_id
      required: false
      secret: false
      deprecated: true
    - default: false
      description: Interval in seconds between each poll.
      isArray: false
      name: interval_in_seconds
      required: false
      secret: false
    - default: false
      description: Polling timeout in seconds.
      isArray: false
      name: timeout_in_seconds
      required: false
      secret: false
    deprecated: false
    description: Initiates a new endpoint script execution kill process.
    execution: false
    name: core-run-script-kill-process
    polling: true
    outputs:
    - contextPath: Core.ScriptRun.action_id
      description: ID of the action initiated.
      type: Number
    - contextPath: Core.ScriptRun.endpoints_count
      description: Number of endpoints the action was initiated on.
      type: Number
  - arguments:
    - default: false
      description: The endpoint ID.
      isArray: true
      name: id
      required: false
      secret: false
    - default: true
      description: The endpoint IP address.
      isArray: true
      name: ip
      required: false
      secret: false
    - default: false
      description: The endpoint hostname.
      isArray: true
      name: hostname
      required: false
      secret: false
    deprecated: false
    description: Returns information about an endpoint.
    execution: false
    name: endpoint
    outputs:
    - contextPath: Endpoint.Hostname
      description: The endpoint's hostname.
      type: String
    - contextPath: Endpoint.OS
      description: The endpoint's operation system.
      type: String
    - contextPath: Endpoint.IPAddress
      description: The endpoint's IP address.
      type: String
    - contextPath: Endpoint.ID
      description: The endpoint's ID.
      type: String
    - contextPath: Endpoint.Status
      description: The endpoint's status.
      type: String
    - contextPath: Endpoint.IsIsolated
      description: The endpoint's isolation status.
      type: String
    - contextPath: Endpoint.MACAddress
      description: The endpoint's MAC address.
      type: String
    - contextPath: Endpoint.Vendor
      description: The integration name of the endpoint vendor.
      type: String
  - arguments:
    - default: false
      description: String that represents the file’s hash. Must be a valid SHA256 hash.
      isArray: false
      name: file_hash
      required: true
      secret: false
    - default: false
      description: The new verdict of the file. 0 - benign, 1 - malware.
      predefined:
      - '0'
      - '1'
      isArray: false
      name: new_verdict
      required: true
      secret: false
    - default: false
      description: String that represents the reason of the report
      isArray: false
      name: reason
      required: true
      secret: false
    - default: false
      description: User’s email address.
      isArray: false
      name: email
      required: true
      secret: false
    deprecated: false
    description: report FP to wildfire through XDR
    execution: true
    name: core-report-incorrect-wildfire
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: String that represents a list of hashed files you want to add to allow list. Must be a valid SHA256 hash.
      isArray: true
      name: hash_list
      required: true
      secret: false
    - default: false
      description: String that represents additional information regarding the action.
      isArray: false
      name: comment
      required: false
      secret: false
    deprecated: false
    description: Removes requested files from allow list.
    execution: false
    name: core-remove-allowlist-files
    outputs:
    - contextPath: Core.allowlist.removed_hashes
      description: Removed file hash
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the incident that triggered it.
      isArray: false
      name: incident_id
      required: false
      secret: false
    - default: false
      description: String that represents a list of hashed files you want to add to allow list. Must be a valid SHA256 hash.
      isArray: true
      name: hash_list
      required: true
      secret: false
    - default: false
      description: String that represents additional information regarding the action.
      isArray: false
      name: comment
      required: false
      secret: false
    deprecated: false
    description: Removes requested files from block list.
    execution: false
    name: core-remove-blocklist-files
    outputs:
    - contextPath: Core.blocklist.removed_hashes
      description: Removed fileHash from blocklist
      type: Number
  - arguments:
    - default: false
      description: Name of the exclusion.
      isArray: false
      name: name
      required: true
      secret: false
    - default: false
      description: 'Filter object for the exclusion. example: {"filter":{"AND":[{"SEARCH_FIELD":"alert_category","SEARCH_TYPE":"NEQ","SEARCH_VALUE":"Phishing"}]}}'
      isArray: false
      name: filterObject
      required: true
      secret: false
    - default: false
      description: String that represents additional information regarding the action.
      isArray: false
      name: comment
      required: false
      secret: false
    - auto: PREDEFINED
      default: false
      defaultValue: 'ENABLED'
      description: Status of exclusion. default value = ENABLED
      isArray: false
      name: status
      predefined:
      - 'ENABLED'
      - 'DISABLED'
      required: false
      secret: false
    deprecated: false
    description: Adds exclusion.
    execution: false
    name: core-add-exclusion
    outputs:
    - contextPath: Core.exclusion.rule_id
      description: Added exclusion rule id
      type: Number
  - arguments:
    - default: false
      description: The desired alert_exclusion_id to be removed
      isArray: false
      name: alert_exclusion_id
      required: true
      secret: false
    deprecated: false
    description: Delete exclusion.
    execution: false
    name: core-delete-exclusion
    outputs:
    - contextPath: Core.deletedExclusion.rule_id
      description: Deleted exclusion rule id
      type: Number
  - arguments:
    - default: false
      description: Allows to link the response action to the tenant that triggered it.
      isArray: false
      name: tenant_ID
      required: false
      secret: false
    - default: false
      description: 'Filter object for the exclusion. example: {"filter":{"AND":[{"SEARCH_FIELD":"alert_category","SEARCH_TYPE":"NEQ","SEARCH_VALUE":"Phishing"}]}}'
      isArray: false
      name: filterObject
      required: false
      secret: false
    - default: false
      description: Limit for the response. You will get the first "limit" exclusions. Default value is 20.
      isArray: false
      name: limit
      required: false
      secret: false
      defaultValue: '20'
    deprecated: false
    description: Gets exclusion list.
    execution: false
    name: core-get-exclusion
    outputs:
    - contextPath: Core.exclusion.ALERT_WHITELIST_ID
      description: ''
      type: Number
    - contextPath: Core.exclusion.ALERT_WHITELIST_MODIFY_TIME
      description: ''
      type: Date
    - contextPath: Core.exclusion.ALERT_WHITELIST_NAME
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR_TEXT.pretty_name
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR_TEXT.data_type
      description: ''
      type: Unknown
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR_TEXT.render_type
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR_TEXT.entity_map
      description: ''
      type: Unknown
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR_TEXT.dml_type
      description: ''
      type: Unknown
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR.filter.AND.SEARCH_FIELD
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR.filter.AND.SEARCH_TYPE
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_INDICATOR.filter.AND.SEARCH_VALUE
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_HITS
      description: ''
      type: Number
    - contextPath: Core.exclusion.ALERT_WHITELIST_COMMENT
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_USER
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_PRETTY_USER
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_STATUS
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_BACKWARDS_SCAN_STATUS
      description: ''
      type: String
    - contextPath: Core.exclusion.ALERT_WHITELIST_BACKWARDS_SCAN_TIMESTAMP
      description: ''
      type: Unknown
    - contextPath: Core.exclusion.ALERT_WHITELIST_MIGRATED_FROM_ANALYTICS
      description: ''
      type: Number
  feed: false
  isfetch: false
  longRunning: false
  longRunningPort: false
  runonce: false
  script: >
    register_module_line('Cortex Core - IR', 'start', __line__())

    import copy

    from operator import itemgetter

    from typing import Tuple, Callable



    import urllib3



    # Disable insecure warnings

    urllib3.disable_warnings()


    TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

    NONCE_LENGTH = 64

    API_KEY_LENGTH = 128


    INTEGRATION_CONTEXT_BRAND = 'Core'

    INTEGRATION_NAME = 'Cortex Core - IR'



    XSOAR_RESOLVED_STATUS_TO_Core = {
        'Other': 'resolved_other',
        'Duplicate': 'resolved_duplicate',
        'False Positive': 'resolved_false_positive',
        'Resolved': 'resolved_true_positive',
    }



    class Client(BaseClient):

        def __init__(self, base_url: str, headers: dict, timeout: int = 120, proxy: bool = False, verify: bool = False):
            self.timeout = timeout
            super().__init__(base_url=base_url, headers=headers, proxy=proxy, verify=verify)

        def test_module(self, first_fetch_time):
            """
                Performs basic get request to get item samples
            """
            last_one_day, _ = parse_date_range(first_fetch_time, TIME_FORMAT)
            try:
                self.get_incidents(lte_creation_time=last_one_day, limit=1)
            except Exception as err:
                if 'API request Unauthorized' in str(err):
                    # this error is received from the Core server when the client clock is not in sync to the server
                    raise DemistoException(f'{str(err)} please validate that your both '
                                           f'XSOAR and Core server clocks are in sync')
                else:
                    raise

        def get_incidents(self, incident_id_list=None, lte_modification_time=None, gte_modification_time=None,
                          lte_creation_time=None, gte_creation_time=None, status=None, sort_by_modification_time=None,
                          sort_by_creation_time=None, page_number=0, limit=100, gte_creation_time_milliseconds=0):
            """
            Filters and returns incidents

            :param incident_id_list: List of incident ids - must be list
            :param lte_modification_time: string of time format "2019-12-31T23:59:00"
            :param gte_modification_time: string of time format "2019-12-31T23:59:00"
            :param lte_creation_time: string of time format "2019-12-31T23:59:00"
            :param gte_creation_time: string of time format "2019-12-31T23:59:00"
            :param status: string of status
            :param sort_by_modification_time: optional - enum (asc,desc)
            :param sort_by_creation_time: optional - enum (asc,desc)
            :param page_number: page number
            :param limit: maximum number of incidents to return per page
            :param gte_creation_time_milliseconds: greater than time in milliseconds
            :return:
            """
            search_from = page_number * limit
            search_to = search_from + limit

            request_data = {
                'search_from': search_from,
                'search_to': search_to,
            }

            if sort_by_creation_time and sort_by_modification_time:
                raise ValueError('Should be provide either sort_by_creation_time or '
                                 'sort_by_modification_time. Can\'t provide both')
            if sort_by_creation_time:
                request_data['sort'] = {
                    'field': 'creation_time',
                    'keyword': sort_by_creation_time
                }
            elif sort_by_modification_time:
                request_data['sort'] = {
                    'field': 'modification_time',
                    'keyword': sort_by_modification_time
                }

            filters = []
            if incident_id_list is not None and len(incident_id_list) > 0:
                filters.append({
                    'field': 'incident_id_list',
                    'operator': 'in',
                    'value': incident_id_list
                })

            if lte_creation_time:
                filters.append({
                    'field': 'creation_time',
                    'operator': 'lte',
                    'value': date_to_timestamp(lte_creation_time, TIME_FORMAT)
                })

            if gte_creation_time:
                filters.append({
                    'field': 'creation_time',
                    'operator': 'gte',
                    'value': date_to_timestamp(gte_creation_time, TIME_FORMAT)
                })

            if lte_modification_time:
                filters.append({
                    'field': 'modification_time',
                    'operator': 'lte',
                    'value': date_to_timestamp(lte_modification_time, TIME_FORMAT)
                })

            if gte_modification_time:
                filters.append({
                    'field': 'modification_time',
                    'operator': 'gte',
                    'value': date_to_timestamp(gte_modification_time, TIME_FORMAT)
                })

            if gte_creation_time_milliseconds > 0:
                filters.append({
                    'field': 'creation_time',
                    'operator': 'gte',
                    'value': gte_creation_time_milliseconds
                })

            if status:
                filters.append({
                    'field': 'status',
                    'operator': 'eq',
                    'value': status
                })

            if len(filters) > 0:
                request_data['filters'] = filters
            res = self._http_request(
                method='POST',
                url_suffix='/incidents/get_incidents/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            incidents = res.get('reply').get('incidents', [])

            return incidents

        def update_incident(self, incident_id, assigned_user_mail, assigned_user_pretty_name, status, severity,
                            resolve_comment, unassign_user):
            update_data = {}

            if unassign_user and (assigned_user_mail or assigned_user_pretty_name):
                raise ValueError("Can't provide both assignee_email/assignee_name and unassign_user")
            if unassign_user:
                update_data['assigned_user_mail'] = 'none'

            if assigned_user_mail:
                update_data['assigned_user_mail'] = assigned_user_mail

            if assigned_user_pretty_name:
                update_data['assigned_user_pretty_name'] = assigned_user_pretty_name

            if status:
                update_data['status'] = status

            if severity:
                update_data['manual_severity'] = severity

            if resolve_comment:
                update_data['resolve_comment'] = resolve_comment

            request_data = {
                'incident_id': incident_id,
                'update_data': update_data,
            }

            self._http_request(
                method='POST',
                url_suffix='/incidents/update_incident/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

        def get_endpoints(self,
                          endpoint_id_list=None,
                          dist_name=None,
                          ip_list=None,
                          group_name=None,
                          platform=None,
                          alias_name=None,
                          isolate=None,
                          hostname=None,
                          page_number=0,
                          limit=30,
                          first_seen_gte=None,
                          first_seen_lte=None,
                          last_seen_gte=None,
                          last_seen_lte=None,
                          sort_by_first_seen=None,
                          sort_by_last_seen=None,
                          status=None,
                          no_filter=False
                          ):

            search_from = page_number * limit
            search_to = search_from + limit

            request_data = {
                'search_from': search_from,
                'search_to': search_to,
            }

            if no_filter:
                reply = self._http_request(
                    method='POST',
                    url_suffix='/endpoints/get_endpoints/',
                    json_data={},
                    timeout=self.timeout
                )
                endpoints = reply.get('reply')[search_from:search_to]
                for endpoint in endpoints:
                    if not endpoint.get('endpoint_id'):
                        endpoint['endpoint_id'] = endpoint.get('agent_id')

            else:
                filters = []

                if status:
                    filters.append({
                        'field': 'endpoint_status',
                        'operator': 'IN',
                        'value': [status]
                    })

                if endpoint_id_list:
                    filters.append({
                        'field': 'endpoint_id_list',
                        'operator': 'in',
                        'value': endpoint_id_list
                    })

                if dist_name:
                    filters.append({
                        'field': 'dist_name',
                        'operator': 'in',
                        'value': dist_name
                    })

                if ip_list:
                    filters.append({
                        'field': 'ip_list',
                        'operator': 'in',
                        'value': ip_list
                    })

                if group_name:
                    filters.append({
                        'field': 'group_name',
                        'operator': 'in',
                        'value': group_name
                    })

                if platform:
                    filters.append({
                        'field': 'platform',
                        'operator': 'in',
                        'value': platform
                    })

                if alias_name:
                    filters.append({
                        'field': 'alias',
                        'operator': 'in',
                        'value': alias_name
                    })

                if isolate:
                    filters.append({
                        'field': 'isolate',
                        'operator': 'in',
                        'value': [isolate]
                    })

                if hostname:
                    filters.append({
                        'field': 'hostname',
                        'operator': 'in',
                        'value': hostname
                    })

                if first_seen_gte:
                    filters.append({
                        'field': 'first_seen',
                        'operator': 'gte',
                        'value': first_seen_gte
                    })

                if first_seen_lte:
                    filters.append({
                        'field': 'first_seen',
                        'operator': 'lte',
                        'value': first_seen_lte
                    })

                if last_seen_gte:
                    filters.append({
                        'field': 'last_seen',
                        'operator': 'gte',
                        'value': last_seen_gte
                    })

                if last_seen_lte:
                    filters.append({
                        'field': 'last_seen',
                        'operator': 'lte',
                        'value': last_seen_lte
                    })

                if search_from:
                    request_data['search_from'] = search_from

                if search_to:
                    request_data['search_to'] = search_to

                if sort_by_first_seen:
                    request_data['sort'] = {
                        'field': 'first_seen',
                        'keyword': sort_by_first_seen
                    }
                elif sort_by_last_seen:
                    request_data['sort'] = {
                        'field': 'last_seen',
                        'keyword': sort_by_last_seen
                    }

                request_data['filters'] = filters

                reply = self._http_request(
                    method='POST',
                    url_suffix='/endpoints/get_endpoint/',
                    json_data={'request_data': request_data},
                    timeout=self.timeout
                )

                endpoints = reply.get('reply').get('endpoints', [])
            return endpoints

        def isolate_endpoint(self, endpoint_id, incident_id=None):
            request_data = {
                'endpoint_id': endpoint_id,
            }
            if incident_id:
                request_data['incident_id'] = incident_id

            reply = self._http_request(
                method='POST',
                url_suffix='/endpoints/isolate',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return reply.get('reply')

        def unisolate_endpoint(self, endpoint_id, incident_id=None):
            request_data = {
                'endpoint_id': endpoint_id,
            }
            if incident_id:
                request_data['incident_id'] = incident_id

            reply = self._http_request(
                method='POST',
                url_suffix='/endpoints/unisolate',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return reply.get('reply')

        def get_distribution_url(self, distribution_id, package_type):
            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/get_dist_url/',
                json_data={
                    'request_data': {
                        'distribution_id': distribution_id,
                        'package_type': package_type
                    }
                },
                timeout=self.timeout
            )

            return reply.get('reply').get('distribution_url')

        def get_distribution_status(self, distribution_id):
            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/get_status/',
                json_data={
                    'request_data': {
                        'distribution_id': distribution_id
                    }
                },
                timeout=self.timeout
            )

            return reply.get('reply').get('status')

        def get_distribution_versions(self):
            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/get_versions/',
                json_data={},
                timeout=self.timeout
            )

            return reply.get('reply')

        def create_distribution(self, name, platform, package_type, agent_version, description):
            request_data = {}
            if package_type == 'standalone':
                request_data = {
                    'name': name,
                    'platform': platform,
                    'package_type': package_type,
                    'agent_version': agent_version,
                    'description': description,
                }
            elif package_type == 'upgrade':
                request_data = {
                    'name': name,
                    'package_type': package_type,
                    'description': description,
                }

                if platform == 'windows':
                    request_data['windows_version'] = agent_version
                elif platform == 'linux':
                    request_data['linux_version'] = agent_version
                elif platform == 'macos':
                    request_data['macos_version'] = agent_version

            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/create/',
                json_data={
                    'request_data': request_data
                },
                timeout=self.timeout
            )

            return reply.get('reply').get('distribution_id')

        def audit_management_logs(self, email, result, _type, sub_type, search_from, search_to, timestamp_gte,
                                  timestamp_lte, sort_by, sort_order):

            request_data: Dict[str, Any] = {}
            filters = []
            if email:
                filters.append({
                    'field': 'email',
                    'operator': 'in',
                    'value': email
                })
            if result:
                filters.append({
                    'field': 'result',
                    'operator': 'in',
                    'value': result
                })
            if _type:
                filters.append({
                    'field': 'type',
                    'operator': 'in',
                    'value': _type
                })
            if sub_type:
                filters.append({
                    'field': 'sub_type',
                    'operator': 'in',
                    'value': sub_type
                })
            if timestamp_gte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'gte',
                    'value': timestamp_gte
                })
            if timestamp_lte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'lte',
                    'value': timestamp_lte
                })

            if filters:
                request_data['filters'] = filters

            if search_from > 0:
                request_data['search_from'] = search_from

            if search_to:
                request_data['search_to'] = search_to

            if sort_by:
                request_data['sort'] = {
                    'field': sort_by,
                    'keyword': sort_order
                }

            reply = self._http_request(
                method='POST',
                url_suffix='/audits/management_logs/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply').get('data', [])

        def get_audit_agent_reports(self, endpoint_ids, endpoint_names, result, _type, sub_type, search_from, search_to,
                                    timestamp_gte, timestamp_lte, sort_by, sort_order):
            request_data: Dict[str, Any] = {}
            filters = []
            if endpoint_ids:
                filters.append({
                    'field': 'endpoint_id',
                    'operator': 'in',
                    'value': endpoint_ids
                })
            if endpoint_names:
                filters.append({
                    'field': 'endpoint_name',
                    'operator': 'in',
                    'value': endpoint_names
                })
            if result:
                filters.append({
                    'field': 'result',
                    'operator': 'in',
                    'value': result
                })
            if _type:
                filters.append({
                    'field': 'type',
                    'operator': 'in',
                    'value': _type
                })
            if sub_type:
                filters.append({
                    'field': 'sub_type',
                    'operator': 'in',
                    'value': sub_type
                })
            if timestamp_gte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'gte',
                    'value': timestamp_gte
                })
            if timestamp_lte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'lte',
                    'value': timestamp_lte
                })

            if filters:
                request_data['filters'] = filters

            if search_from > 0:
                request_data['search_from'] = search_from

            if search_to:
                request_data['search_to'] = search_to

            if sort_by:
                request_data['sort'] = {
                    'field': sort_by,
                    'keyword': sort_order
                }

            reply = self._http_request(
                method='POST',
                url_suffix='/audits/agents_reports/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply').get('data', [])

        def blocklist_files(self, hash_list, comment=None, incident_id=None, detailed_response=False):
            request_data: Dict[str, Any] = {"hash_list": hash_list}
            if comment:
                request_data["comment"] = comment
            if incident_id:
                request_data['incident_id'] = incident_id
            if detailed_response:
                request_data['detailed_response'] = detailed_response

            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix='/hash_exceptions/blocklist/',
                json_data={'request_data': request_data},
                ok_codes=(200, 201, 500,),
                timeout=self.timeout
            )
            return reply.get('reply')

        def remove_blocklist_files(self, hash_list, comment=None, incident_id=None):
            request_data: Dict[str, Any] = {"hash_list": hash_list}
            if comment:
                request_data["comment"] = comment
            if incident_id:
                request_data['incident_id'] = incident_id

            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix='/hash_exceptions/blocklist/remove/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return reply.get('reply')

        def allowlist_files(self, hash_list, comment=None, incident_id=None, detailed_response=False):
            request_data: Dict[str, Any] = {"hash_list": hash_list}
            if comment:
                request_data["comment"] = comment
            if incident_id:
                request_data['incident_id'] = incident_id
            if detailed_response:
                request_data['detailed_response'] = detailed_response

            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix='/hash_exceptions/allowlist/',
                json_data={'request_data': request_data},
                ok_codes=(201, 200),
                timeout=self.timeout
            )
            return reply.get('reply')

        def remove_allowlist_files(self, hash_list, comment=None, incident_id=None):
            request_data: Dict[str, Any] = {"hash_list": hash_list}
            if comment:
                request_data["comment"] = comment
            if incident_id:
                request_data['incident_id'] = incident_id

            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix='/hash_exceptions/allowlist/remove/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return reply.get('reply')

        def quarantine_files(self, endpoint_id_list, file_path, file_hash, incident_id):
            request_data: Dict[str, Any] = {}
            filters = []
            if endpoint_id_list:
                filters.append({
                    'field': 'endpoint_id_list',
                    'operator': 'in',
                    'value': endpoint_id_list
                })

            if filters:
                request_data['filters'] = filters

            request_data['file_path'] = file_path
            request_data['file_hash'] = file_hash
            if incident_id:
                request_data['incident_id'] = incident_id

            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix='/endpoints/quarantine/',
                json_data={'request_data': request_data},
                ok_codes=(200, 201),
                timeout=self.timeout
            )

            return reply.get('reply')

        def restore_file(self, file_hash, endpoint_id=None, incident_id=None):
            request_data: Dict[str, Any] = {'file_hash': file_hash}
            if incident_id:
                request_data['incident_id'] = incident_id
            if endpoint_id:
                request_data['endpoint_id'] = endpoint_id

            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix='/endpoints/restore/',
                json_data={'request_data': request_data},
                ok_codes=(200, 201),
                timeout=self.timeout
            )
            return reply.get('reply')

        def endpoint_scan(self, url_suffix, endpoint_id_list=None, dist_name=None, gte_first_seen=None, gte_last_seen=None,
                          lte_first_seen=None,
                          lte_last_seen=None, ip_list=None, group_name=None, platform=None, alias=None, isolate=None,
                          hostname: list = None, incident_id=None):
            request_data: Dict[str, Any] = {}
            filters = []

            if endpoint_id_list:
                filters.append({
                    'field': 'endpoint_id_list',
                    'operator': 'in',
                    'value': endpoint_id_list
                })

            if dist_name:
                filters.append({
                    'field': 'dist_name',
                    'operator': 'in',
                    'value': dist_name
                })

            if ip_list:
                filters.append({
                    'field': 'ip_list',
                    'operator': 'in',
                    'value': ip_list
                })

            if group_name:
                filters.append({
                    'field': 'group_name',
                    'operator': 'in',
                    'value': group_name
                })

            if platform:
                filters.append({
                    'field': 'platform',
                    'operator': 'in',
                    'value': platform
                })

            if alias:
                filters.append({
                    'field': 'alias',
                    'operator': 'in',
                    'value': alias
                })

            if isolate:
                filters.append({
                    'field': 'isolate',
                    'operator': 'in',
                    'value': [isolate]
                })

            if hostname:
                filters.append({
                    'field': 'hostname',
                    'operator': 'in',
                    'value': hostname
                })

            if gte_first_seen:
                filters.append({
                    'field': 'first_seen',
                    'operator': 'gte',
                    'value': gte_first_seen
                })

            if lte_first_seen:
                filters.append({
                    'field': 'first_seen',
                    'operator': 'lte',
                    'value': lte_first_seen
                })

            if gte_last_seen:
                filters.append({
                    'field': 'last_seen',
                    'operator': 'gte',
                    'value': gte_last_seen
                })

            if lte_last_seen:
                filters.append({
                    'field': 'last_seen',
                    'operator': 'lte',
                    'value': lte_last_seen
                })

            if filters:
                request_data['filters'] = filters
            else:
                request_data['filters'] = 'all'
            if incident_id:
                request_data['incident_id'] = incident_id

            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix=url_suffix,
                json_data={'request_data': request_data},
                ok_codes=(200, 201),
                timeout=self.timeout
            )
            return reply.get('reply')

        def get_quarantine_status(self, file_path, file_hash, endpoint_id):
            request_data: Dict[str, Any] = {'files': [{
                'endpoint_id': endpoint_id,
                'file_path': file_path,
                'file_hash': file_hash
            }]}
            self._headers['content-type'] = 'application/json'
            reply = self._http_request(
                method='POST',
                url_suffix='/quarantine/status/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            reply_content = reply.get('reply')
            if isinstance(reply_content, list):
                return reply_content[0]
            else:
                raise TypeError(f'got unexpected response from api: {reply_content}\n')

        def delete_endpoints(self, endpoint_ids: list):
            request_data: Dict[str, Any] = {
                'filters': [
                    {
                        'field': 'endpoint_id_list',
                        'operator': 'in',
                        'value': endpoint_ids
                    }
                ]
            }

            self._http_request(
                method='POST',
                url_suffix='/endpoints/delete/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

        def get_policy(self, endpoint_id) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                'endpoint_id': endpoint_id
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/endpoints/get_policy/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply')

        def report_incorrect_wildfire(self, file_hash: str, new_verdict: int, reason: str, email: str) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                "hash": file_hash,
                "new_verdict": new_verdict,
                "reason": reason,
                "email": email,
            }

            reply = demisto._apiCall(name="wfReportIncorrectVerdict",
                                     params=None,
                                     data=json.dumps(request_data))

            return reply

        def get_endpoint_device_control_violations(self, endpoint_ids: list, type_of_violation, timestamp_gte: int,
                                                   timestamp_lte: int,
                                                   ip_list: list, vendor: list, vendor_id: list, product: list,
                                                   product_id: list,
                                                   serial: list,
                                                   hostname: list, violation_ids: list, username: list) \
                -> Dict[str, Any]:
            arg_list = {'type': type_of_violation,
                        'endpoint_id_list': endpoint_ids,
                        'ip_list': ip_list,
                        'vendor': vendor,
                        'vendor_id': vendor_id,
                        'product': product,
                        'product_id': product_id,
                        'serial': serial,
                        'hostname': hostname,
                        'violation_id_list': violation_ids,
                        'username': username
                        }

            filters: list = [{
                'field': arg_key,
                'operator': 'in',
                'value': arg_val
            } for arg_key, arg_val in arg_list.items() if arg_val and arg_val[0]]

            if timestamp_lte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'lte',
                    'value': timestamp_lte
                })
            if timestamp_gte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'gte',
                    'value': timestamp_gte})

            request_data: Dict[str, Any] = {
                'filters': filters
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/device_control/get_violations/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply')

        def generate_files_dict_with_specific_os(self, windows: list, linux: list, macos: list) -> Dict[str, list]:
            if not windows and not linux and not macos:
                raise ValueError('You should enter at least one path.')

            files = {}
            if windows:
                files['windows'] = windows
            if linux:
                files['linux'] = linux
            if macos:
                files['macos'] = macos

            return files

        def retrieve_file(self, endpoint_id_list: list, windows: list, linux: list, macos: list, file_path_list: list,
                          incident_id: Optional[int]) -> Dict[str, Any]:
            # there are 2 options, either the paths are given with separation to a specific os or without
            # it using generic_file_path
            if file_path_list:
                files = self.generate_files_dict(
                    endpoint_id_list=endpoint_id_list,
                    file_path_list=file_path_list
                )
            else:
                files = self.generate_files_dict_with_specific_os(windows=windows, linux=linux, macos=macos)

            request_data: Dict[str, Any] = {
                'filters': [
                    {
                        'field': 'endpoint_id_list',
                        'operator': 'in',
                        'value': endpoint_id_list
                    }
                ],
                'files': files,
            }
            if incident_id:
                request_data['incident_id'] = incident_id

            reply = self._http_request(
                method='POST',
                url_suffix='/endpoints/file_retrieval/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return reply.get('reply')

        def generate_files_dict(self, endpoint_id_list: list, file_path_list: list) -> Dict[str, Any]:
            files: dict = {"windows": [], "linux": [], "macos": []}

            if len(endpoint_id_list) != len(file_path_list):
                raise ValueError("The endpoint_ids list must be in the same length as the generic_file_path")

            for endpoint_id, file_path in zip(endpoint_id_list, file_path_list):
                endpoints = self.get_endpoints(endpoint_id_list=[endpoint_id])

                if len(endpoints) == 0 or not isinstance(endpoints, list):
                    raise ValueError(f'Error: Endpoint {endpoint_id} was not found')

                endpoint = endpoints[0]
                endpoint_os_type = endpoint.get('os_type')

                if 'windows' in endpoint_os_type.lower():
                    files['windows'].append(file_path)
                elif 'linux' in endpoint_os_type.lower():
                    files['linux'].append(file_path)
                elif 'macos' in endpoint_os_type.lower():
                    files['macos'].append(file_path)

            # remove keys with no value
            files = {k: v for k, v in files.items() if v}

            return files

        def retrieve_file_details(self, action_id: int) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                'group_action_id': action_id
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/actions/file_retrieval_details/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply').get('data')

        def get_scripts(self, name: list, description: list, created_by: list, windows_supported,
                        linux_supported, macos_supported, is_high_risk) -> Dict[str, Any]:

            arg_list = {'name': name,
                        'description': description,
                        'created_by': created_by,
                        'windows_supported': windows_supported,
                        'linux_supported': linux_supported,
                        'macos_supported': macos_supported,
                        'is_high_risk': is_high_risk
                        }

            filters: list = [{
                'field': arg_key,
                'operator': 'in',
                'value': arg_val
            } for arg_key, arg_val in arg_list.items() if arg_val and arg_val[0]]

            request_data: Dict[str, Any] = {
                'filters': filters
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/scripts/get_scripts/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply')

        def get_script_metadata(self, script_uid) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                'script_uid': script_uid
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/scripts/get_script_metadata/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply')

        def get_script_code(self, script_uid) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                'script_uid': script_uid
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/scripts/get_script_code/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

            return reply.get('reply')

        @logger
        def run_script(self,
                       script_uid: str, endpoint_ids: list, parameters: Dict[str, Any], timeout: int, incident_id: Optional[int],
                       ) -> Dict[str, Any]:
            filters: list = [{
                'field': 'endpoint_id_list',
                'operator': 'in',
                'value': endpoint_ids
            }]
            request_data: Dict[str, Any] = {'script_uid': script_uid, 'timeout': timeout, 'filters': filters,
                                            'parameters_values': parameters}
            if incident_id:
                request_data['incident_id'] = incident_id

            return self._http_request(
                method='POST',
                url_suffix='/scripts/run_script/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

        @logger
        def run_snippet_code_script(self, snippet_code: str, endpoint_ids: list,
                                    incident_id: Optional[int] = None) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                'filters': [{
                    'field': 'endpoint_id_list',
                    'operator': 'in',
                    'value': endpoint_ids
                }],
                'snippet_code': snippet_code,
            }

            if incident_id:
                request_data['incident_id'] = incident_id

            return self._http_request(
                method='POST',
                url_suffix='/scripts/run_snippet_code_script',
                json_data={
                    'request_data': request_data
                },
                timeout=self.timeout,
            )

        @logger
        def get_script_execution_status(self, action_id: str) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                'action_id': action_id
            }

            return self._http_request(
                method='POST',
                url_suffix='/scripts/get_script_execution_status/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )

        @logger
        def get_script_execution_results(self, action_id: str) -> Dict[str, Any]:
            return self._http_request(
                method='POST',
                url_suffix='/scripts/get_script_execution_results',
                json_data={
                    'request_data': {
                        'action_id': action_id
                    }
                },
                timeout=self.timeout,
            )

        @logger
        def get_script_execution_result_files(self, action_id: str, endpoint_id: str) -> Dict[str, Any]:
            response = self._http_request(
                method='POST',
                url_suffix='/scripts/get_script_execution_results_files',
                json_data={
                    'request_data': {
                        'action_id': action_id,
                        'endpoint_id': endpoint_id,
                    }
                },
                timeout=self.timeout,
            )
            link = response.get('reply', {}).get('DATA')
            return self._http_request(
                method='GET',
                full_url=link,
                resp_type='response',
            )

        def action_status_get(self, action_id) -> Dict[str, Any]:
            request_data: Dict[str, Any] = {
                'group_action_id': action_id,
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/actions/get_action_status/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return reply.get('reply').get('data')

        def get_file(self, file_link):
            reply = self._http_request(
                method='GET',
                full_url=file_link,
                timeout=self.timeout,
                resp_type='content'
            )
            return reply

        def add_exclusion(self, indicator, name, status="ENABLED", comment=None):
            request_data: Dict[str, Any] = {
                'indicator': indicator,
                'status': status,
                'name': name
            }

            res = self._http_request(
                method='POST',
                url_suffix='/alerts_exclusion/add/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return res.get("reply")

        def delete_exclusion(self, alert_exclusion_id: int):
            request_data: Dict[str, Any] = {
                'alert_exclusion_id': alert_exclusion_id,
            }

            res = self._http_request(
                method='POST',
                url_suffix='/alerts_exclusion/delete/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            return res.get("reply")

        def get_exclusion(self, limit, tenant_id=None, filter=None):
            request_data: Dict[str, Any] = {}
            if tenant_id:
                request_data['tenant_id'] = tenant_id
            if filter:
                request_data['filter_data'] = filter
            res = self._http_request(
                method='POST',
                url_suffix='/alerts_exclusion/',
                json_data={'request_data': request_data},
                timeout=self.timeout
            )
            reply = res.get("reply")
            return reply[:limit]


    def create_endpoint_context(audit_logs):
        endpoints = []
        for log in audit_logs:
            endpoint_details = {
                'ID': log.get('ENDPOINTID'),
                'Hostname': log.get('ENDPOINTNAME'),
                'Domain': log.get('DOMAIN'),
            }
            remove_nulls_from_dictionary(endpoint_details)
            if endpoint_details:
                endpoints.append(endpoint_details)

        return endpoints


    def create_account_context(endpoints):
        account_context = []
        for endpoint in endpoints:
            domain = endpoint.get('domain')
            if domain:
                users = endpoint.get('users', [])  # in case the value of 'users' is None
                if users and isinstance(users, list):
                    for user in users:
                        account_context.append({
                            'Username': user,
                            'Domain': domain,
                        })

        return account_context


    def get_process_context(alert, process_type):
        process_context = {
            'Name': alert.get(f'{process_type}_process_image_name'),
            'MD5': alert.get(f'{process_type}_process_image_md5'),
            'SHA256': alert.get(f'{process_type}_process_image_sha256'),
            'PID': alert.get(f'{process_type}_process_os_pid'),
            'CommandLine': alert.get(f'{process_type}_process_command_line'),
            'Path': alert.get(f'{process_type}_process_image_path'),
            'Start Time': alert.get(f'{process_type}_process_execution_time'),
            'Hostname': alert.get('host_name'),
        }

        remove_nulls_from_dictionary(process_context)

        # If the process contains only 'HostName' , don't create an indicator
        if len(process_context.keys()) == 1 and 'Hostname' in process_context.keys():
            return {}
        return process_context


    def add_to_ip_context(alert, ip_context):
        action_local_ip = alert.get('action_local_ip')
        action_remote_ip = alert.get('action_remote_ip')
        if action_local_ip:
            ip_context.append({
                'Address': action_local_ip,
            })

        if action_remote_ip:
            ip_context.append({
                'Address': action_remote_ip,
            })


    def create_context_from_network_artifacts(network_artifacts, ip_context):
        domain_context = []

        if network_artifacts:
            for artifact in network_artifacts:
                domain = artifact.get('network_domain')
                if domain:
                    domain_context.append({
                        'Name': domain,
                    })

                network_ip_details = {
                    'Address': artifact.get('network_remote_ip'),
                    'GEO': {
                        'Country': artifact.get('network_country')},
                }

                remove_nulls_from_dictionary(network_ip_details)

                if network_ip_details:
                    ip_context.append(network_ip_details)

        return domain_context


    def update_incident_command(client, args):
        incident_id = args.get('incident_id')
        assigned_user_mail = args.get('assigned_user_mail')
        assigned_user_pretty_name = args.get('assigned_user_pretty_name')
        status = args.get('status')
        severity = args.get('manual_severity')
        unassign_user = args.get('unassign_user') == 'true'
        resolve_comment = args.get('resolve_comment')

        client.update_incident(
            incident_id=incident_id,
            assigned_user_mail=assigned_user_mail,
            assigned_user_pretty_name=assigned_user_pretty_name,
            unassign_user=unassign_user,
            status=status,
            severity=severity,
            resolve_comment=resolve_comment
        )

        return f'Incident {incident_id} has been updated', None, None


    def arg_to_int(arg, arg_name: str, required: bool = False):
        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None
        if isinstance(arg, str):
            if arg.isdigit():
                return int(arg)
            raise ValueError(f'Invalid number: "{arg_name}"="{arg}"')
        if isinstance(arg, int):
            return arg
        return ValueError(f'Invalid number: "{arg_name}"')


    def get_endpoints_command(client, args):
        page_number = arg_to_int(
            arg=args.get('page', '0'),
            arg_name='Failed to parse "page". Must be a number.',
            required=True
        )

        limit = arg_to_int(
            arg=args.get('limit', '30'),
            arg_name='Failed to parse "limit". Must be a number.',
            required=True
        )

        if list(args.keys()) == ['limit', 'page', 'sort_order']:
            endpoints = client.get_endpoints(page_number=page_number, limit=limit, no_filter=True)
        else:
            endpoint_id_list = argToList(args.get('endpoint_id_list'))
            dist_name = argToList(args.get('dist_name'))
            ip_list = argToList(args.get('ip_list'))
            group_name = argToList(args.get('group_name'))
            platform = argToList(args.get('platform'))
            alias_name = argToList(args.get('alias_name'))
            isolate = args.get('isolate')
            hostname = argToList(args.get('hostname'))
            status = args.get('status')

            first_seen_gte = arg_to_timestamp(
                arg=args.get('first_seen_gte'),
                arg_name='first_seen_gte'
            )

            first_seen_lte = arg_to_timestamp(
                arg=args.get('first_seen_lte'),
                arg_name='first_seen_lte'
            )

            last_seen_gte = arg_to_timestamp(
                arg=args.get('last_seen_gte'),
                arg_name='last_seen_gte'
            )

            last_seen_lte = arg_to_timestamp(
                arg=args.get('last_seen_lte'),
                arg_name='last_seen_lte'
            )

            sort_by_first_seen = args.get('sort_by_first_seen')
            sort_by_last_seen = args.get('sort_by_last_seen')

            endpoints = client.get_endpoints(
                endpoint_id_list=endpoint_id_list,
                dist_name=dist_name,
                ip_list=ip_list,
                group_name=group_name,
                platform=platform,
                alias_name=alias_name,
                isolate=isolate,
                hostname=hostname,
                page_number=page_number,
                limit=limit,
                first_seen_gte=first_seen_gte,
                first_seen_lte=first_seen_lte,
                last_seen_gte=last_seen_gte,
                last_seen_lte=last_seen_lte,
                sort_by_first_seen=sort_by_first_seen,
                sort_by_last_seen=sort_by_last_seen,
                status=status
            )

        standard_endpoints = generate_endpoint_by_contex_standard(endpoints, False)
        endpoint_context_list = []
        for endpoint in standard_endpoints:
            endpoint_context = endpoint.to_context().get(Common.Endpoint.CONTEXT_PATH)
            endpoint_context_list.append(endpoint_context)

        context = {
            f'{INTEGRATION_CONTEXT_BRAND}.Endpoint(val.endpoint_id == obj.endpoint_id)': endpoints,
            Common.Endpoint.CONTEXT_PATH: endpoint_context_list
        }
        account_context = create_account_context(endpoints)
        if account_context:
            context[Common.Account.CONTEXT_PATH] = account_context

        return CommandResults(
            readable_output=tableToMarkdown('Endpoints', endpoints),
            outputs=context,
            raw_response=endpoints
        )


    def convert_os_to_standard(endpoint_os):
        os_type = ''
        endpoint_os = endpoint_os.lower()
        if 'windows' in endpoint_os:
            os_type = "Windows"
        elif 'linux' in endpoint_os:
            os_type = "Linux"
        elif 'macos' in endpoint_os:
            os_type = "Macos"
        elif 'android' in endpoint_os:
            os_type = "Android"
        return os_type


    def get_endpoint_properties(single_endpoint):
        status = 'Online' if single_endpoint.get('endpoint_status', '').lower() == 'connected' else 'Offline'
        is_isolated = 'No' if 'unisolated' in single_endpoint.get('is_isolated', '').lower() else 'Yes'
        hostname = single_endpoint['host_name'] if single_endpoint.get('host_name') else single_endpoint.get(
            'endpoint_name')
        ip = single_endpoint.get('ip')
        return status, is_isolated, hostname, ip


    def generate_endpoint_by_contex_standard(endpoints, ip_as_string):
        standard_endpoints = []
        for single_endpoint in endpoints:
            status, is_isolated, hostname, ip = get_endpoint_properties(single_endpoint)
            # in the `core-get-endpoints` command the ip is returned as list, in order not to break bc we will keep it
            # in the `endpoint` command we use the standard
            if ip_as_string and isinstance(ip, list):
                ip = ip[0]
            os_type = convert_os_to_standard(single_endpoint.get('os_type', ''))
            endpoint = Common.Endpoint(
                id=single_endpoint.get('endpoint_id'),
                hostname=hostname,
                ip_address=ip,
                os=os_type,
                status=status,
                is_isolated=is_isolated,
                mac_address=single_endpoint.get('mac_address'),
                domain=single_endpoint.get('domain'),
                vendor=INTEGRATION_NAME)

            standard_endpoints.append(endpoint)
        return standard_endpoints


    def endpoint_command(client, args):
        endpoint_id_list = argToList(args.get('id'))
        endpoint_ip_list = argToList(args.get('ip'))
        endpoint_hostname_list = argToList(args.get('hostname'))

        endpoints = client.get_endpoints(
            endpoint_id_list=endpoint_id_list,
            ip_list=endpoint_ip_list,
            hostname=endpoint_hostname_list,
        )
        standard_endpoints = generate_endpoint_by_contex_standard(endpoints, True)
        command_results = []
        if standard_endpoints:
            for endpoint in standard_endpoints:
                endpoint_context = endpoint.to_context().get(Common.Endpoint.CONTEXT_PATH)
                hr = tableToMarkdown('Cortex Core Endpoint', endpoint_context)

                command_results.append(CommandResults(
                    readable_output=hr,
                    raw_response=endpoints,
                    indicator=endpoint
                ))

        else:
            command_results.append(CommandResults(
                readable_output="No endpoints were found",
                raw_response=endpoints,
            ))
        return command_results


    def isolate_endpoint_command(client, args):
        endpoint_id = args.get('endpoint_id')
        disconnected_should_return_error = not argToBoolean(args.get('suppress_disconnected_endpoint_error', False))
        incident_id = arg_to_number(args.get('incident_id'))
        endpoint = client.get_endpoints(endpoint_id_list=[endpoint_id])
        if len(endpoint) == 0:
            raise ValueError(f'Error: Endpoint {endpoint_id} was not found')

        endpoint = endpoint[0]
        endpoint_status = endpoint.get('endpoint_status')
        is_isolated = endpoint.get('is_isolated')
        if is_isolated == 'AGENT_ISOLATED':
            return CommandResults(
                readable_output=f'Endpoint {endpoint_id} already isolated.'
            )
        if is_isolated == 'AGENT_PENDING_ISOLATION':
            return CommandResults(
                readable_output=f'Endpoint {endpoint_id} pending isolation.'
            )
        if endpoint_status == 'UNINSTALLED':
            raise ValueError(f'Error: Endpoint {endpoint_id}\'s Agent is uninstalled and therefore can not be isolated.')
        if endpoint_status == 'DISCONNECTED':
            if disconnected_should_return_error:
                raise ValueError(f'Error: Endpoint {endpoint_id} is disconnected and therefore can not be isolated.')
            else:
                return CommandResults(
                    readable_output=f'Warning: isolation action is pending for the following disconnected endpoint: {endpoint_id}.',
                    outputs={f'{INTEGRATION_CONTEXT_BRAND}.Isolation.endpoint_id(val.endpoint_id == obj.endpoint_id)': endpoint_id}
                )
        if is_isolated == 'AGENT_PENDING_ISOLATION_CANCELLATION':
            raise ValueError(
                f'Error: Endpoint {endpoint_id} is pending isolation cancellation and therefore can not be isolated.'
            )
        result = client.isolate_endpoint(endpoint_id=endpoint_id, incident_id=incident_id)

        return CommandResults(
            readable_output=f'The isolation request has been submitted successfully on Endpoint {endpoint_id}.\n',
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.Isolation.endpoint_id(val.endpoint_id == obj.endpoint_id)': endpoint_id},
            raw_response=result
        )


    def unisolate_endpoint_command(client, args):
        endpoint_id = args.get('endpoint_id')
        incident_id = arg_to_number(args.get('incident_id'))

        disconnected_should_return_error = not argToBoolean(args.get('suppress_disconnected_endpoint_error', False))
        endpoint = client.get_endpoints(endpoint_id_list=[endpoint_id])
        if len(endpoint) == 0:
            raise ValueError(f'Error: Endpoint {endpoint_id} was not found')

        endpoint = endpoint[0]
        endpoint_status = endpoint.get('endpoint_status')
        is_isolated = endpoint.get('is_isolated')
        if is_isolated == 'AGENT_UNISOLATED':
            return CommandResults(
                readable_output=f'Endpoint {endpoint_id} already unisolated.'
            )
        if is_isolated == 'AGENT_PENDING_ISOLATION_CANCELLATION':
            return CommandResults(
                readable_output=f'Endpoint {endpoint_id} pending isolation cancellation.'
            )
        if endpoint_status == 'UNINSTALLED':
            raise ValueError(f'Error: Endpoint {endpoint_id}\'s Agent is uninstalled and therefore can not be un-isolated.')
        if endpoint_status == 'DISCONNECTED':
            if disconnected_should_return_error:
                raise ValueError(f'Error: Endpoint {endpoint_id} is disconnected and therefore can not be un-isolated.')
            else:
                return CommandResults(
                    readable_output=f'Warning: un-isolation action is pending for the following disconnected '
                                    f'endpoint: {endpoint_id}.',
                    outputs={
                        f'{INTEGRATION_CONTEXT_BRAND}.UnIsolation.endpoint_id(val.endpoint_id == obj.endpoint_id)'
                        f'': endpoint_id}
                )
        if is_isolated == 'AGENT_PENDING_ISOLATION':
            raise ValueError(
                f'Error: Endpoint {endpoint_id} is pending isolation and therefore can not be un-isolated.'
            )
        result = client.unisolate_endpoint(endpoint_id=endpoint_id, incident_id=incident_id)

        return CommandResults(
            readable_output=f'The un-isolation request has been submitted successfully on Endpoint {endpoint_id}.\n',
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.UnIsolation.endpoint_id(val.endpoint_id == obj.endpoint_id)': endpoint_id},
            raw_response=result
        )


    def arg_to_timestamp(arg, arg_name: str, required: bool = False):
        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None

        if isinstance(arg, str) and arg.isdigit():
            # timestamp that str - we just convert it to int
            return int(arg)
        if isinstance(arg, str):
            # if the arg is string of date format 2019-10-23T00:00:00 or "3 days", etc
            date = dateparser.parse(arg, settings={'TIMEZONE': 'UTC'})
            if date is None:
                # if d is None it means dateparser failed to parse it
                raise ValueError(f'Invalid date: {arg_name}')

            return int(date.timestamp() * 1000)
        if isinstance(arg, (int, float)):
            return arg


    def get_audit_management_logs_command(client, args):
        email = argToList(args.get('email'))
        result = argToList(args.get('result'))
        _type = argToList(args.get('type'))
        sub_type = argToList(args.get('sub_type'))

        timestamp_gte = arg_to_timestamp(
            arg=args.get('timestamp_gte'),
            arg_name='timestamp_gte'
        )

        timestamp_lte = arg_to_timestamp(
            arg=args.get('timestamp_lte'),
            arg_name='timestamp_lte'
        )

        page_number = arg_to_int(
            arg=args.get('page', 0),
            arg_name='Failed to parse "page". Must be a number.',
            required=True
        )
        limit = arg_to_int(
            arg=args.get('limit', 20),
            arg_name='Failed to parse "limit". Must be a number.',
            required=True
        )
        search_from = page_number * limit
        search_to = search_from + limit

        sort_by = args.get('sort_by')
        sort_order = args.get('sort_order', 'asc')

        audit_logs = client.audit_management_logs(
            email=email,
            result=result,
            _type=_type,
            sub_type=sub_type,
            timestamp_gte=timestamp_gte,
            timestamp_lte=timestamp_lte,
            search_from=search_from,
            search_to=search_to,
            sort_by=sort_by,
            sort_order=sort_order
        )

        return (
            tableToMarkdown('Audit Management Logs', audit_logs, [
                'AUDIT_ID',
                'AUDIT_RESULT',
                'AUDIT_DESCRIPTION',
                'AUDIT_OWNER_NAME',
                'AUDIT_OWNER_EMAIL',
                'AUDIT_ASSET_JSON',
                'AUDIT_ASSET_NAMES',
                'AUDIT_HOSTNAME',
                'AUDIT_REASON',
                'AUDIT_ENTITY',
                'AUDIT_ENTITY_SUBTYPE',
                'AUDIT_SESSION_ID',
                'AUDIT_CASE_ID',
                'AUDIT_INSERT_TIME'
            ]),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.AuditManagementLogs(val.AUDIT_ID == obj.AUDIT_ID)': audit_logs
            },
            audit_logs
        )


    def get_audit_agent_reports_command(client, args):
        endpoint_ids = argToList(args.get('endpoint_ids'))
        endpoint_names = argToList(args.get('endpoint_names'))
        result = argToList(args.get('result'))
        _type = argToList(args.get('type'))
        sub_type = argToList(args.get('sub_type'))

        timestamp_gte = arg_to_timestamp(
            arg=args.get('timestamp_gte'),
            arg_name='timestamp_gte'
        )

        timestamp_lte = arg_to_timestamp(
            arg=args.get('timestamp_lte'),
            arg_name='timestamp_lte'
        )

        page_number = arg_to_int(
            arg=args.get('page', 0),
            arg_name='Failed to parse "page". Must be a number.',
            required=True
        )
        limit = arg_to_int(
            arg=args.get('limit', 20),
            arg_name='Failed to parse "limit". Must be a number.',
            required=True
        )
        search_from = page_number * limit
        search_to = search_from + limit

        sort_by = args.get('sort_by')
        sort_order = args.get('sort_order', 'asc')

        audit_logs = client.get_audit_agent_reports(
            endpoint_ids=endpoint_ids,
            endpoint_names=endpoint_names,
            result=result,
            _type=_type,
            sub_type=sub_type,
            timestamp_gte=timestamp_gte,
            timestamp_lte=timestamp_lte,

            search_from=search_from,
            search_to=search_to,
            sort_by=sort_by,
            sort_order=sort_order
        )
        integration_context = {f'{INTEGRATION_CONTEXT_BRAND}.AuditAgentReports': audit_logs}
        endpoint_context = create_endpoint_context(audit_logs)
        if endpoint_context:
            integration_context[Common.Endpoint.CONTEXT_PATH] = endpoint_context
        return (
            tableToMarkdown('Audit Agent Reports', audit_logs),
            integration_context,
            audit_logs
        )


    def get_distribution_url_command(client, args):
        distribution_id = args.get('distribution_id')
        package_type = args.get('package_type')

        url = client.get_distribution_url(distribution_id, package_type)

        return (
            f'[Distribution URL]({url})',
            {
                'Core.Distribution(val.id == obj.id)': {
                    'id': distribution_id,
                    'url': url
                }
            },
            url
        )


    def get_distribution_status_command(client, args):
        distribution_ids = argToList(args.get('distribution_ids'))

        distribution_list = []
        for distribution_id in distribution_ids:
            status = client.get_distribution_status(distribution_id)

            distribution_list.append({
                'id': distribution_id,
                'status': status
            })

        return (
            tableToMarkdown('Distribution Status', distribution_list, ['id', 'status']),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Distribution(val.id == obj.id)': distribution_list
            },
            distribution_list
        )


    def get_distribution_versions_command(client):
        versions = client.get_distribution_versions()

        readable_output = []
        for operation_system in versions.keys():
            os_versions = versions[operation_system]

            readable_output.append(
                tableToMarkdown(operation_system, os_versions or [], ['versions'])
            )

        return (
            '\n\n'.join(readable_output),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.DistributionVersions': versions
            },
            versions
        )


    def create_distribution_command(client, args):
        name = args.get('name')
        platform = args.get('platform')
        package_type = args.get('package_type')
        description = args.get('description')
        agent_version = args.get('agent_version')
        if not platform == 'android' and not agent_version:
            # agent_version must be provided for all the platforms except android
            raise ValueError(f'Missing argument "agent_version" for platform "{platform}"')

        distribution_id = client.create_distribution(
            name=name,
            platform=platform,
            package_type=package_type,
            agent_version=agent_version,
            description=description
        )

        distribution = {
            'id': distribution_id,
            'name': name,
            'platform': platform,
            'package_type': package_type,
            'agent_version': agent_version,
            'description': description
        }

        return (
            f'Distribution {distribution_id} created successfully',
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Distribution(val.id == obj.id)': distribution
            },
            distribution
        )


    def blocklist_files_command(client, args):
        hash_list = argToList(args.get('hash_list'))
        comment = args.get('comment')
        incident_id = arg_to_number(args.get('incident_id'))
        detailed_response = argToBoolean(args.get('detailed_response', False))

        res = client.blocklist_files(hash_list=hash_list,
                                     comment=comment,
                                     incident_id=incident_id,
                                     detailed_response=detailed_response)

        if detailed_response:
            return CommandResults(
                readable_output=tableToMarkdown('Blocklist Files', res),
                outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.blocklist',
                outputs=res,
                raw_response=res
            )

        markdown_data = [{'added_hashes': file_hash} for file_hash in hash_list]

        return CommandResults(
            readable_output=tableToMarkdown('Blocklist Files',
                                            markdown_data,
                                            headers=['added_hashes'],
                                            headerTransform=pascalToSpace),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.blocklist.added_hashes.fileHash(val.fileHash == obj.fileHash)': hash_list},
            raw_response=res
        )


    def remove_blocklist_files_command(client: Client, args: Dict) -> CommandResults:
        hash_list = argToList(args.get('hash_list'))
        comment = args.get('comment')
        incident_id = arg_to_number(args.get('incident_id'))

        res = client.remove_blocklist_files(hash_list=hash_list, comment=comment, incident_id=incident_id)
        if isinstance(res, dict) and res.get('err_extra') != "All hashes have already been added to the allow or block list":
            raise ValueError(res)
        markdown_data = [{'removed_hashes': file_hash} for file_hash in hash_list]

        return CommandResults(
            readable_output=tableToMarkdown('Blocklist Files Removed',
                                            markdown_data,
                                            headers=['removed_hashes'],
                                            headerTransform=pascalToSpace),
            outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.blocklist',
            outputs=markdown_data,
            raw_response=res
        )


    def allowlist_files_command(client, args):
        hash_list = argToList(args.get('hash_list'))
        comment = args.get('comment')
        incident_id = arg_to_number(args.get('incident_id'))
        detailed_response = argToBoolean(args.get('detailed_response', False))

        res = client.allowlist_files(hash_list=hash_list,
                                     comment=comment,
                                     incident_id=incident_id,
                                     detailed_response=detailed_response)
        if detailed_response:
            return CommandResults(
                readable_output=tableToMarkdown('Allowlist Files', res),
                outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.blocklist',
                outputs=res,
                raw_response=res
            )

        markdown_data = [{'added_hashes': file_hash} for file_hash in hash_list]

        return CommandResults(
            readable_output=tableToMarkdown('Allowlist Files',
                                            markdown_data,
                                            headers=['added_hashes'],
                                            headerTransform=pascalToSpace),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.allowlist.added_hashes.fileHash(val.fileHash == obj.fileHash)': hash_list},
            raw_response=res
        )


    def remove_allowlist_files_command(client, args):
        hash_list = argToList(args.get('hash_list'))
        comment = args.get('comment')
        incident_id = arg_to_number(args.get('incident_id'))
        res = client.remove_allowlist_files(hash_list=hash_list, comment=comment, incident_id=incident_id)
        markdown_data = [{'removed_hashes': file_hash} for file_hash in hash_list]
        return CommandResults(
            readable_output=tableToMarkdown('Allowlist Files Removed',
                                            markdown_data,
                                            headers=['removed_hashes'],
                                            headerTransform=pascalToSpace),
            outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.allowlist',
            outputs=markdown_data,
            raw_response=res
        )


    def quarantine_files_command(client, args):
        endpoint_id_list = argToList(args.get("endpoint_id_list"))
        file_path = args.get("file_path")
        file_hash = args.get("file_hash")
        incident_id = arg_to_number(args.get('incident_id'))

        reply = client.quarantine_files(
            endpoint_id_list=endpoint_id_list,
            file_path=file_path,
            file_hash=file_hash,
            incident_id=incident_id
        )
        output = {
            'endpointIdList': endpoint_id_list,
            'filePath': file_path,
            'fileHash': file_hash,
            'actionId': reply.get("action_id")
        }

        return CommandResults(
            readable_output=tableToMarkdown('Quarantine files', output, headers=[*output], headerTransform=pascalToSpace),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.quarantineFiles.actionIds(val.actionId === obj.actionId)': output},
            raw_response=reply
        )


    def restore_file_command(client, args):
        file_hash = args.get('file_hash')
        endpoint_id = args.get('endpoint_id')
        incident_id = arg_to_number(args.get('incident_id'))

        reply = client.restore_file(
            file_hash=file_hash,
            endpoint_id=endpoint_id,
            incident_id=incident_id
        )
        action_id = reply.get("action_id")

        return CommandResults(
            readable_output=tableToMarkdown('Restore files', {'Action Id': action_id}, ['Action Id']),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.restoredFiles.actionId(val.actionId == obj.actionId)': action_id},
            raw_response=reply
        )


    def get_quarantine_status_command(client, args):
        file_path = args.get('file_path')
        file_hash = args.get('file_hash')
        endpoint_id = args.get('endpoint_id')

        reply = client.get_quarantine_status(
            file_path=file_path,
            file_hash=file_hash,
            endpoint_id=endpoint_id
        )
        output = {
            'status': reply['status'],
            'endpointId': reply['endpoint_id'],
            'filePath': reply['file_path'],
            'fileHash': reply['file_hash']
        }

        return CommandResults(
            readable_output=tableToMarkdown('Quarantine files status', output, headers=[*output], headerTransform=pascalToSpace),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.quarantineFiles.status(val.fileHash === obj.fileHash &&'
                     f'val.endpointId === obj.endpointId && val.filePath === obj.filePath)': output},
            raw_response=reply
        )


    def endpoint_scan_command(client, args):
        endpoint_id_list = argToList(args.get('endpoint_id_list'))
        dist_name = argToList(args.get('dist_name'))
        gte_first_seen = args.get('gte_first_seen')
        gte_last_seen = args.get('gte_last_seen')
        lte_first_seen = args.get('lte_first_seen')
        lte_last_seen = args.get('lte_last_seen')
        ip_list = argToList(args.get('ip_list'))
        group_name = argToList(args.get('group_name'))
        platform = argToList(args.get('platform'))
        alias = argToList(args.get('alias'))
        isolate = args.get('isolate')
        hostname = argToList(args.get('hostname'))
        incident_id = arg_to_number(args.get('incident_id'))

        validate_args_scan_commands(args)

        reply = client.endpoint_scan(
            url_suffix='/endpoints/scan/',
            endpoint_id_list=argToList(endpoint_id_list),
            dist_name=dist_name,
            gte_first_seen=gte_first_seen,
            gte_last_seen=gte_last_seen,
            lte_first_seen=lte_first_seen,
            lte_last_seen=lte_last_seen,
            ip_list=ip_list,
            group_name=group_name,
            platform=platform,
            alias=alias,
            isolate=isolate,
            hostname=hostname,
            incident_id=incident_id
        )

        action_id = reply.get("action_id")

        context = {
            "actionId": action_id,
            "aborted": False
        }

        return CommandResults(
            readable_output=tableToMarkdown('Endpoint scan', {'Action Id': action_id}, ['Action Id']),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.endpointScan(val.actionId == obj.actionId)': context},
            raw_response=reply
        )


    def endpoint_scan_abort_command(client, args):
        endpoint_id_list = argToList(args.get('endpoint_id_list'))
        dist_name = argToList(args.get('dist_name'))
        gte_first_seen = args.get('gte_first_seen')
        gte_last_seen = args.get('gte_last_seen')
        lte_first_seen = args.get('lte_first_seen')
        lte_last_seen = args.get('lte_last_seen')
        ip_list = argToList(args.get('ip_list'))
        group_name = argToList(args.get('group_name'))
        platform = argToList(args.get('platform'))
        alias = argToList(args.get('alias'))
        isolate = args.get('isolate')
        hostname = argToList(args.get('hostname'))
        incident_id = arg_to_number(args.get('incident_id'))

        validate_args_scan_commands(args)

        reply = client.endpoint_scan(
            url_suffix='endpoints/abort_scan/',
            endpoint_id_list=argToList(endpoint_id_list),
            dist_name=dist_name,
            gte_first_seen=gte_first_seen,
            gte_last_seen=gte_last_seen,
            lte_first_seen=lte_first_seen,
            lte_last_seen=lte_last_seen,
            ip_list=ip_list,
            group_name=group_name,
            platform=platform,
            alias=alias,
            isolate=isolate,
            hostname=hostname,
            incident_id=incident_id
        )

        action_id = reply.get("action_id")

        context = {
            "actionId": action_id,
            "aborted": True
        }

        return CommandResults(
            readable_output=tableToMarkdown('Endpoint abort scan', {'Action Id': action_id}, ['Action Id']),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.endpointScan(val.actionId == obj.actionId)': context},
            raw_response=reply
        )


    def validate_args_scan_commands(args):
        endpoint_id_list = argToList(args.get('endpoint_id_list'))
        dist_name = argToList(args.get('dist_name'))
        gte_first_seen = args.get('gte_first_seen')
        gte_last_seen = args.get('gte_last_seen')
        lte_first_seen = args.get('lte_first_seen')
        lte_last_seen = args.get('lte_last_seen')
        ip_list = argToList(args.get('ip_list'))
        group_name = argToList(args.get('group_name'))
        platform = argToList(args.get('platform'))
        alias = argToList(args.get('alias'))
        hostname = argToList(args.get('hostname'))
        all_ = argToBoolean(args.get('all', 'false'))

        # to prevent the case where an empty filtered command will trigger by default a scan on all the endpoints.
        err_msg = 'To scan/abort scan all the endpoints run this command with the \'all\' argument as True ' \
                  'and without any other filters. This may cause performance issues.\n' \
                  'To scan/abort scan some of the endpoints, please use the filter arguments.'
        if all_:
            if endpoint_id_list or dist_name or gte_first_seen or gte_last_seen or lte_first_seen or lte_last_seen \
                    or ip_list or group_name or platform or alias or hostname:
                raise Exception(err_msg)
        else:
            if not endpoint_id_list and not dist_name and not gte_first_seen and not gte_last_seen \
                    and not lte_first_seen and not lte_last_seen and not ip_list and not group_name and not platform \
                    and not alias and not hostname:
                raise Exception(err_msg)


    def sort_by_key(list_to_sort, main_key, fallback_key):
        """Sorts a given list elements by main_key for all elements with the key,
        uses sorting by fallback_key on all elements that dont have the main_key"""
        list_elements_with_main_key = [element for element in list_to_sort if element.get(main_key)]
        sorted_list = sorted(list_elements_with_main_key, key=itemgetter(main_key))
        if len(list_to_sort) == len(sorted_list):
            return sorted_list

        list_elements_with_fallback_without_main = [element for element in list_to_sort
                                                    if element.get(fallback_key) and not element.get(main_key)]
        sorted_list.extend(sorted(list_elements_with_fallback_without_main, key=itemgetter(fallback_key)))

        if len(sorted_list) == len(list_to_sort):
            return sorted_list

        list_elements_without_fallback_and_main = [element for element in list_to_sort
                                                   if not element.get(fallback_key) and not element.get(main_key)]

        sorted_list.extend(list_elements_without_fallback_and_main)
        return sorted_list


    def drop_field_underscore(section):
        section_copy = section.copy()
        for field in section_copy.keys():
            if '_' in field:
                section[field.replace('_', '')] = section.get(field)


    def reformat_sublist_fields(sublist):
        for section in sublist:
            drop_field_underscore(section)


    def handle_outgoing_incident_owner_sync(update_args):
        if 'owner' in update_args and demisto.params().get('sync_owners'):
            if update_args.get('owner'):
                user_info = demisto.findUser(username=update_args.get('owner'))
                if user_info:
                    update_args['assigned_user_mail'] = user_info.get('email')
            else:
                # handle synced unassignment
                update_args['assigned_user_mail'] = None


    def handle_user_unassignment(update_args):
        if ('assigned_user_mail' in update_args and update_args.get('assigned_user_mail') in ['None', 'null', '', None]) \
                or ('assigned_user_pretty_name' in update_args
                    and update_args.get('assigned_user_pretty_name') in ['None', 'null', '', None]):
            update_args['unassign_user'] = 'true'
            update_args['assigned_user_mail'] = None
            update_args['assigned_user_pretty_name'] = None


    def handle_outgoing_issue_closure(update_args, inc_status):
        if inc_status == 2:
            update_args['status'] = XSOAR_RESOLVED_STATUS_TO_Core.get(update_args.get('closeReason', 'Other'))
            demisto.debug(f"Closing Remote Core incident with status {update_args['status']}")
            update_args['resolve_comment'] = update_args.get('closeNotes', '')


    def get_update_args(delta, inc_status):
        """Change the updated field names to fit the update command"""
        update_args = delta
        handle_outgoing_incident_owner_sync(update_args)
        handle_user_unassignment(update_args)
        if update_args.get('closingUserId'):
            handle_outgoing_issue_closure(update_args, inc_status)
        return update_args


    def update_remote_system_command(client, args):
        remote_args = UpdateRemoteSystemArgs(args)

        if remote_args.delta:
            demisto.debug(f'Got the following delta keys {str(list(remote_args.delta.keys()))} to update Core '
                          f'incident {remote_args.remote_incident_id}')
        try:
            if remote_args.incident_changed:
                update_args = get_update_args(remote_args.delta, remote_args.inc_status)

                update_args['incident_id'] = remote_args.remote_incident_id
                demisto.debug(f'Sending incident with remote ID [{remote_args.remote_incident_id}] to Core\n')
                update_incident_command(client, update_args)

            else:
                demisto.debug(f'Skipping updating remote incident fields [{remote_args.remote_incident_id}] '
                              f'as it is not new nor changed')

            return remote_args.remote_incident_id

        except Exception as e:
            demisto.debug(f"Error in Core outgoing mirror for incident {remote_args.remote_incident_id} \n"
                          f"Error message: {str(e)}")

            return remote_args.remote_incident_id


    def delete_endpoints_command(client: Client, args: Dict[str, str]) -> Tuple[str, Any, Any]:
        endpoint_id_list: list = argToList(args.get('endpoint_ids'))

        client.delete_endpoints(endpoint_id_list)

        return f'Successfully deleted the following endpoints: {args.get("endpoint_ids")}', None, None


    def get_policy_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        endpoint_id = args.get('endpoint_id')

        reply = client.get_policy(endpoint_id)
        context = {'endpoint_id': endpoint_id,
                   'policy_name': reply.get('policy_name')}

        return (
            f'The policy name of endpoint: {endpoint_id} is: {reply.get("policy_name")}.',
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Policy(val.endpoint_id == obj.endpoint_id)': context
            },
            reply
        )


    def get_endpoint_device_control_violations_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        endpoint_ids: list = argToList(args.get('endpoint_ids'))
        type_of_violation = args.get('type')
        timestamp_gte: int = arg_to_timestamp(
            arg=args.get('timestamp_gte'),
            arg_name='timestamp_gte'
        )
        timestamp_lte: int = arg_to_timestamp(
            arg=args.get('timestamp_lte'),
            arg_name='timestamp_lte'
        )
        ip_list: list = argToList(args.get('ip_list'))
        vendor: list = argToList(args.get('vendor'))
        vendor_id: list = argToList(args.get('vendor_id'))
        product: list = argToList(args.get('product'))
        product_id: list = argToList(args.get('product_id'))
        serial: list = argToList(args.get('serial'))
        hostname: list = argToList(args.get('hostname'))
        violation_id_list: list = argToList(args.get('violation_id_list', ''))
        username: list = argToList(args.get('username'))

        violation_ids = [arg_to_int(arg=item, arg_name=str(item)) for item in violation_id_list]

        reply = client.get_endpoint_device_control_violations(
            endpoint_ids=endpoint_ids,
            type_of_violation=[type_of_violation],
            timestamp_gte=timestamp_gte,
            timestamp_lte=timestamp_lte,
            ip_list=ip_list,
            vendor=vendor,
            vendor_id=vendor_id,
            product=product,
            product_id=product_id,
            serial=serial,
            hostname=hostname,
            violation_ids=violation_ids,
            username=username
        )

        headers = ['date', 'hostname', 'platform', 'username', 'ip', 'type', 'violation_id', 'vendor', 'product',
                   'serial']
        violations: list = copy.deepcopy(reply.get('violations'))  # type: ignore
        for violation in violations:
            timestamp: str = violation.get('timestamp')
            violation['date'] = timestamp_to_datestring(timestamp, TIME_FORMAT)

        return (
            tableToMarkdown(name='Endpoint Device Control Violation', t=violations, headers=headers,
                            headerTransform=string_to_table_header, removeNull=True),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.EndpointViolations(val.violation_id==obj.violation_id)': violations
            },
            reply
        )


    def retrieve_files_command(client: Client, args: Dict[str, str]) -> CommandResults:
        endpoint_id_list: list = argToList(args.get('endpoint_ids'))
        windows: list = argToList(args.get('windows_file_paths'))
        linux: list = argToList(args.get('linux_file_paths'))
        macos: list = argToList(args.get('mac_file_paths'))
        file_path_list: list = argToList(args.get('generic_file_path'))
        incident_id: Optional[int] = arg_to_number(args.get('incident_id'))

        reply = client.retrieve_file(
            endpoint_id_list=endpoint_id_list,
            windows=windows,
            linux=linux,
            macos=macos,
            file_path_list=file_path_list,
            incident_id=incident_id
        )

        result = {'action_id': reply.get('action_id')}

        return CommandResults(
            readable_output=tableToMarkdown(name='Retrieve files', t=result, headerTransform=string_to_table_header),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.RetrievedFiles(val.action_id == obj.action_id)': result},
            raw_response=reply
        )


    def retrieve_file_details_command(client: Client, args):
        action_id_list = argToList(args.get('action_id', ''))
        action_id_list = [arg_to_int(arg=item, arg_name=str(item)) for item in action_id_list]

        result = []
        raw_result = []
        file_results = []
        endpoints_count = 0
        retrived_files_count = 0

        for action_id in action_id_list:
            data = client.retrieve_file_details(action_id)
            raw_result.append(data)

            for endpoint, link in data.items():
                endpoints_count += 1
                obj = {
                    'action_id': action_id,
                    'endpoint_id': endpoint
                }
                if link:
                    retrived_files_count += 1
                    obj['file_link'] = link
                    file = client.get_file(file_link=link)
                    file_results.append(fileResult(filename=f'{endpoint}_{retrived_files_count}.zip', data=file))
                result.append(obj)

        hr = f'### Action id : {args.get("action_id", "")} \n Retrieved {retrived_files_count} files from ' \
             f'{endpoints_count} endpoints. \n To get the exact action status run the core-action-status-get command'

        return_entry = {'Type': entryTypes['note'],
                        'ContentsFormat': formats['json'],
                        'Contents': raw_result,
                        'HumanReadable': hr,
                        'ReadableContentsFormat': formats['markdown'],
                        'EntryContext': {}
                        }
        return return_entry, file_results


    def get_scripts_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        script_name: list = argToList(args.get('script_name'))
        description: list = argToList(args.get('description'))
        created_by: list = argToList(args.get('created_by'))
        windows_supported = args.get('windows_supported')
        linux_supported = args.get('linux_supported')
        macos_supported = args.get('macos_supported')
        is_high_risk = args.get('is_high_risk')
        offset = arg_to_int(arg=args.get('offset', 0), arg_name='offset')
        limit = arg_to_int(arg=args.get('limit', 50), arg_name='limit')

        result = client.get_scripts(
            name=script_name,
            description=description,
            created_by=created_by,
            windows_supported=[windows_supported],
            linux_supported=[linux_supported],
            macos_supported=[macos_supported],
            is_high_risk=[is_high_risk]
        )
        scripts = copy.deepcopy(result.get('scripts')[offset:(offset + limit)])  # type: ignore
        for script in scripts:
            timestamp = script.get('modification_date')
            script['modification_date_timestamp'] = timestamp
            script['modification_date'] = timestamp_to_datestring(timestamp, TIME_FORMAT)
        headers: list = ['name', 'description', 'script_uid', 'modification_date', 'created_by',
                         'windows_supported', 'linux_supported', 'macos_supported', 'is_high_risk']

        return (
            tableToMarkdown(name='Scripts', t=scripts, headers=headers, removeNull=True,
                            headerTransform=string_to_table_header),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Scripts(val.script_uid == obj.script_uid)': scripts
            },
            result
        )


    def get_script_metadata_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        script_uid = args.get('script_uid')

        reply = client.get_script_metadata(script_uid)
        script_metadata = copy.deepcopy(reply)

        timestamp = script_metadata.get('modification_date')
        script_metadata['modification_date_timestamp'] = timestamp
        script_metadata['modification_date'] = timestamp_to_datestring(timestamp, TIME_FORMAT)

        return (
            tableToMarkdown(name='Script Metadata', t=script_metadata, removeNull=True,
                            headerTransform=string_to_table_header),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.ScriptMetadata(val.script_uid == obj.script_uid)': reply
            },
            reply
        )


    def get_script_code_command(client: Client, args: Dict[str, str]) -> Tuple[str, dict, Any]:
        script_uid = args.get('script_uid')

        reply = client.get_script_code(script_uid)
        context = {
            'script_uid': script_uid,
            'code': reply
        }

        return (
            f'### Script code: \n ``` {str(reply)} ```',
            {
                f'{INTEGRATION_CONTEXT_BRAND}.ScriptCode(val.script_uid == obj.script_uid)': context
            },
            reply
        )


    def action_status_get_command(client: Client, args) -> CommandResults:
        action_id_list = argToList(args.get('action_id', ''))
        action_id_list = [arg_to_int(arg=item, arg_name=str(item)) for item in action_id_list]

        result = []
        for action_id in action_id_list:
            data = client.action_status_get(action_id)

            for endpoint_id, status in data.items():
                result.append({
                    'action_id': action_id,
                    'endpoint_id': endpoint_id,
                    'status': status
                })

        return CommandResults(
            readable_output=tableToMarkdown(name='Get Action Status', t=result, removeNull=True),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.GetActionStatus(val.action_id == obj.action_id)': result},
            raw_response=result
        )


    def run_script_command(client: Client, args: Dict) -> CommandResults:
        script_uid = args.get('script_uid')
        endpoint_ids = argToList(args.get('endpoint_ids'))
        timeout = arg_to_number(args.get('timeout', 600)) or 600
        incident_id = arg_to_number(args.get('incident_id'))
        if parameters := args.get('parameters'):
            try:
                parameters = json.loads(parameters)
            except json.decoder.JSONDecodeError as e:
                raise ValueError(f'The parameters argument is not in a valid JSON structure:\n{e}')
        else:
            parameters = {}
        response = client.run_script(script_uid, endpoint_ids, parameters, timeout, incident_id=incident_id)
        reply = response.get('reply')
        return CommandResults(
            readable_output=tableToMarkdown('Run Script', reply),
            outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptRun',
            outputs_key_field='action_id',
            outputs=reply,
            raw_response=response,
        )


    def run_snippet_code_script_command(client: Client, args: Dict) -> CommandResults:
        snippet_code = args.get('snippet_code')
        endpoint_ids = argToList(args.get('endpoint_ids'))
        incident_id = arg_to_number(args.get('incident_id'))
        response = client.run_snippet_code_script(snippet_code=snippet_code, endpoint_ids=endpoint_ids, incident_id=incident_id)
        reply = response.get('reply')
        return CommandResults(
            readable_output=tableToMarkdown('Run Snippet Code Script', reply),
            outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptRun',
            outputs_key_field='action_id',
            outputs=reply,
            raw_response=reply,
        )


    def get_script_execution_status_command(client: Client, args: Dict) -> List[CommandResults]:
        action_ids = argToList(args.get('action_id', ''))
        command_results = []
        for action_id in action_ids:
            response = client.get_script_execution_status(action_id)
            reply = response.get('reply')
            reply['action_id'] = int(action_id)
            command_results.append(CommandResults(
                readable_output=tableToMarkdown(f'Script Execution Status - {action_id}', reply),
                outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptStatus',
                outputs_key_field='action_id',
                outputs=reply,
                raw_response=response,
            ))
        return command_results


    def get_script_execution_results_command(client: Client, args: Dict) -> List[CommandResults]:
        action_ids = argToList(args.get('action_id', ''))
        command_results = []
        for action_id in action_ids:
            response = client.get_script_execution_results(action_id)
            results = response.get('reply', {}).get('results')
            context = {
                'action_id': int(action_id),
                'results': results,
            }
            command_results.append(CommandResults(
                readable_output=tableToMarkdown(f'Script Execution Results - {action_id}', results),
                outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptResult',
                outputs_key_field='action_id',
                outputs=context,
                raw_response=response,
            ))
        return command_results


    def get_script_execution_result_files_command(client: Client, args: Dict) -> Dict:
        action_id = args.get('action_id', '')
        endpoint_id = args.get('endpoint_id')
        file_response = client.get_script_execution_result_files(action_id, endpoint_id)
        try:
            filename = file_response.headers.get('Content-Disposition').split('attachment; filename=')[1]
        except Exception as e:
            demisto.debug(f'Failed extracting filename from response headers - [{str(e)}]')
            filename = action_id + '.zip'
        return fileResult(filename, file_response.content)


    def run_script_execute_commands_command(client: Client, args: Dict) -> CommandResults:
        endpoint_ids = argToList(args.get('endpoint_ids'))
        incident_id = arg_to_number(args.get('incident_id'))
        timeout = arg_to_number(args.get('timeout', 600)) or 600
        parameters = {'commands_list': argToList(args.get('commands'))}
        response = client.run_script('a6f7683c8e217d85bd3c398f0d3fb6bf', endpoint_ids, parameters, timeout, incident_id)
        reply = response.get('reply')
        return CommandResults(
            readable_output=tableToMarkdown('Run Script Execute Commands', reply),
            outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptRun',
            outputs_key_field='action_id',
            outputs=reply,
            raw_response=reply,
        )


    def run_script_delete_file_command(client: Client, args: Dict) -> List[CommandResults]:
        endpoint_ids = argToList(args.get('endpoint_ids'))
        incident_id = arg_to_number(args.get('incident_id'))
        timeout = arg_to_number(args.get('timeout', 600)) or 600
        file_paths = argToList(args.get('file_path'))
        all_files_response = []
        for file_path in file_paths:
            parameters = {'file_path': file_path}
            response = client.run_script('548023b6e4a01ec51a495ba6e5d2a15d', endpoint_ids, parameters, timeout, incident_id)
            reply = response.get('reply')
            all_files_response.append(CommandResults(
                readable_output=tableToMarkdown(f'Run Script Delete File on {file_path}', reply),
                outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptRun',
                outputs_key_field='action_id',
                outputs=reply,
                raw_response=reply,
            ))
        return all_files_response


    def run_script_file_exists_command(client: Client, args: Dict) -> List[CommandResults]:
        endpoint_ids = argToList(args.get('endpoint_ids'))
        incident_id = arg_to_number(args.get('incident_id'))
        timeout = arg_to_number(args.get('timeout', 600)) or 600
        file_paths = argToList(args.get('file_path'))
        all_files_response = []
        for file_path in file_paths:
            parameters = {'path': file_path}
            response = client.run_script('414763381b5bfb7b05796c9fe690df46', endpoint_ids, parameters, timeout, incident_id)
            reply = response.get('reply')
            all_files_response.append(CommandResults(
                readable_output=tableToMarkdown(f'Run Script File Exists on {file_path}', reply),
                outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptRun',
                outputs_key_field='action_id',
                outputs=reply,
                raw_response=reply,
            ))
        return all_files_response


    def run_script_kill_process_command(client: Client, args: Dict) -> List[CommandResults]:
        endpoint_ids = argToList(args.get('endpoint_ids'))
        incident_id = arg_to_number(args.get('incident_id'))
        timeout = arg_to_number(args.get('timeout', 600)) or 600
        processes_names = argToList(args.get('process_name'))
        all_processes_response = []
        for process_name in processes_names:
            parameters = {'process_name': process_name}
            response = client.run_script('fd0a544a99a9421222b4f57a11839481', endpoint_ids, parameters, timeout, incident_id)
            reply = response.get('reply')
            all_processes_response.append(CommandResults(
                readable_output=tableToMarkdown(f'Run Script Kill Process on {process_name}', reply),
                outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.ScriptRun',
                outputs_key_field='action_id',
                outputs=reply,
                raw_response=reply,
            ))

        return all_processes_response


    def add_exclusion_command(client: Client, args: Dict) -> CommandResults:
        name = args.get('name')
        if not name:
            raise DemistoException("Didn't get name arg. This arg is required.")
        indicator = args.get('filterObject')
        if not indicator:
            raise DemistoException("Didn't get filterObject arg. This arg is required.")
        status = args.get('status', "ENABLED")
        comment = args.get('comment')

        res = client.add_exclusion(name=name,
                                   status=status,
                                   indicator=json.loads(indicator),
                                   comment=comment)

        return CommandResults(
            readable_output=tableToMarkdown('Add Exclusion', res),
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.exclusion.rule_id(val.rule_id == obj.rule_id)': res.get("rule_id")},
            raw_response=res
        )


    def delete_exclusion_command(client: Client, args: Dict) -> CommandResults:
        alert_exclusion_id = arg_to_number(args.get('alert_exclusion_id'))
        if not alert_exclusion_id:
            raise DemistoException("Didn't get alert_exclusion_id arg. This arg is required.")

        res = client.delete_exclusion(alert_exclusion_id=alert_exclusion_id)

        return CommandResults(
            readable_output=f"Successfully deleted the following exclusion: {alert_exclusion_id}",
            outputs={f'{INTEGRATION_CONTEXT_BRAND}.deletedExclusion.rule_id(val.rule_id == obj.rule_id)': res.get("rule_id")},
            raw_response=res
        )


    def get_exclusion_command(client: Client, args: Dict) -> CommandResults:

        res = client.get_exclusion(tenant_id=args.get('tenant_ID'),
                                   filter=args.get('filterObject'),
                                   limit=arg_to_number(args.get('limit', 20)))

        return CommandResults(
            outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.exclusion',
            outputs=res,
            readable_output=tableToMarkdown('Exclusion', res),
            raw_response=res
        )


    def report_incorrect_wildfire_command(client: Client, args) -> CommandResults:
        file_hash = args.get('file_hash')
        reason = args.get('reason')
        email = args.get('email')
        new_verdict = arg_to_int(
            arg=args.get('new_verdict'),
            arg_name='Failed to parse "new_verdict". Must be a number.',
            required=True
        )

        response = client.report_incorrect_wildfire(file_hash, new_verdict, reason, email)
        return CommandResults(
            readable_output=f'Reported incorrect WildFire on {file_hash}',
            outputs_prefix=f'{INTEGRATION_CONTEXT_BRAND}.WildFire',
            outputs={"file_hash": file_hash, "new_verdict": new_verdict},
            raw_response=response,
        )


    def run_polling_command(client: Client,
                            args: dict,
                            cmd: str,
                            command_function: Callable,
                            command_decision_field: str,
                            results_function: Callable,
                            polling_field: str,
                            polling_value: List,
                            stop_polling: bool = False) -> CommandResults:
        """
        args: demito args
        cmd: the command to schedule by after the current command
        command_function: the function which is runs the actual command
        command_decision_field: the field in the response based on it what the command status and if the command occurred
        results_function: the function which we are polling on and retrieves the status of the command_function
        polling_field: the field which from the result of the results_function which we are interested in its value
        polling_value: list of values of the polling_field we want to check
        stop_polling: yes - polling_value is stopping, not - polling_value not stopping
        """

        ScheduledCommand.raise_error_if_not_supported()
        interval_in_secs = int(args.get('interval_in_seconds', 60))
        timeout_in_seconds = int(args.get('timeout_in_seconds', 600))
        if command_decision_field not in args:
            # create new command run
            command_results = command_function(client, args)
            if isinstance(command_results, CommandResults):
                outputs = [command_results.raw_response] if command_results.raw_response else []
            else:
                outputs = [c.raw_response for c in command_results]
            command_decision_values = [o.get(command_decision_field) for o in outputs] if outputs else []  # type: ignore
            if outputs and command_decision_values:
                polling_args = {
                    command_decision_field: command_decision_values,
                    'interval_in_seconds': interval_in_secs,
                    **args
                }
                scheduled_command = ScheduledCommand(
                    command=cmd,
                    next_run_in_seconds=interval_in_secs,
                    args=polling_args,
                    timeout_in_seconds=timeout_in_seconds)
                if isinstance(command_results, list):
                    command_results = command_results[0]
                command_results.scheduled_command = scheduled_command
                return command_results
            else:
                if command_results.readable_output:
                    demisto.error(f"{command_results.readable_output}")
                else:
                    demisto.error(f"Command {command_function} didn't succeeded, returned {outputs}")
                return command_results
        # get polling result
        command_results = results_function(client, args)
        outputs_result_func = command_results.raw_response
        result = outputs_result_func.get(polling_field) if isinstance(outputs_result_func, dict) else\
            outputs_result_func[0].get(polling_field)
        cond = result not in polling_value if stop_polling else result in polling_value
        if cond:
            # schedule next poll
            polling_args = {
                'interval_in_seconds': interval_in_secs,
                **args
            }
            scheduled_command = ScheduledCommand(
                command=cmd,
                next_run_in_seconds=interval_in_secs,
                args=polling_args,
                timeout_in_seconds=timeout_in_seconds)

            # result with scheduled_command only - no update to the war room
            command_results = CommandResults(scheduled_command=scheduled_command)
        return command_results


    def main():
        """
        Executes an integration command
        """
        command = demisto.command()
        LOG(f'Command being called is {command}')
        args = demisto.args()
        api_key = demisto.params().get('apikey')
        api_key_id = demisto.params().get('apikey_id')
        url = demisto.params().get('url')
        if not api_key or not api_key_id or not url:
            headers = {
                "HOST": demisto.getLicenseCustomField("Core.ApiHostName"),
                demisto.getLicenseCustomField("Core.ApiHeader"): demisto.getLicenseCustomField("Core.ApiKey"),
                "Content-Type": "application/json"
            }
            url = "http://" + demisto.getLicenseCustomField("Core.ApiHost") + "/api/webapp/"
        else:
            headers = {
                "Content-Type": "application/json",
                "x-xdr-auth-id": str(api_key_id),
                "Authorization": api_key
            }

        base_url = urljoin(url, '/public_api/v1')
        proxy = demisto.params().get('proxy')
        verify_cert = not demisto.params().get('insecure', False)

        try:
            timeout = int(demisto.params().get('timeout', 120))
        except ValueError as e:
            demisto.debug(f'Failed casting timeout parameter to int, falling back to 120 - {e}')
            timeout = 120

        client = Client(
            base_url=base_url,
            proxy=proxy,
            verify=verify_cert,
            headers=headers,
            timeout=timeout
        )

        try:
            if command == 'test-module':
                client.test_module('3 days')
                demisto.results('ok')

            elif command == 'core-get-endpoints':
                return_results(get_endpoints_command(client, args))

            elif command == 'core-isolate-endpoint':
                polling_args = {
                    **args,
                    "endpoint_id_list": args.get('endpoint_id')
                }
                return_results(run_polling_command(client=client,
                                                   args=polling_args,
                                                   cmd="core-isolate-endpoint",
                                                   command_function=isolate_endpoint_command,
                                                   command_decision_field="action_id",
                                                   results_function=get_endpoints_command,
                                                   polling_field="is_isolated",
                                                   polling_value=["AGENT_ISOLATED"],
                                                   stop_polling=True))

            elif command == 'core-unisolate-endpoint':
                polling_args = {
                    **args,
                    "endpoint_id_list": args.get('endpoint_id')
                }
                return_results(run_polling_command(client=client,
                                                   args=polling_args,
                                                   cmd="core-unisolate-endpoint",
                                                   command_function=unisolate_endpoint_command,
                                                   command_decision_field="action_id",
                                                   results_function=get_endpoints_command,
                                                   polling_field="is_isolated",
                                                   polling_value=["AGENT_UNISOLATED",
                                                                  "CANCELLED",
                                                                  "ֿPENDING_ABORT",
                                                                  "ABORTED",
                                                                  "EXPIRED",
                                                                  "COMPLETED_PARTIAL",
                                                                  "COMPLETED_SUCCESSFULLY",
                                                                  "FAILED",
                                                                  "TIMEOUT"],
                                                   stop_polling=True))

            elif command == 'core-get-distribution-url':
                return_outputs(*get_distribution_url_command(client, args))

            elif command == 'core-get-create-distribution-status':
                return_outputs(*get_distribution_status_command(client, args))

            elif command == 'core-get-distribution-versions':
                return_outputs(*get_distribution_versions_command(client))

            elif command == 'core-create-distribution':
                return_outputs(*create_distribution_command(client, args))

            elif command == 'core-get-audit-management-logs':
                return_outputs(*get_audit_management_logs_command(client, args))

            elif command == 'core-get-audit-agent-reports':
                return_outputs(*get_audit_agent_reports_command(client, args))

            elif command == 'core-blocklist-files':
                return_results(blocklist_files_command(client, args))

            elif command == 'core-allowlist-files':
                return_results(allowlist_files_command(client, args))

            elif command == 'core-quarantine-files':
                polling_args = {
                    **args,
                    "endpoint_id": argToList(args.get("endpoint_id_list"))[0]
                }
                return_results(run_polling_command(client=client,
                                                   args=polling_args,
                                                   cmd="core-quarantine-files",
                                                   command_function=quarantine_files_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-get-quarantine-status':
                return_results(get_quarantine_status_command(client, args))

            elif command == 'core-restore-file':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-retrieve-files",
                                                   command_function=restore_file_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-endpoint-scan':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-retrieve-files",
                                                   command_function=endpoint_scan_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-endpoint-scan-abort':
                return_results(endpoint_scan_abort_command(client, args))

            elif command == 'update-remote-system':
                return_results(update_remote_system_command(client, args))

            elif command == 'core-delete-endpoints':
                return_outputs(*delete_endpoints_command(client, args))

            elif command == 'core-get-policy':
                return_outputs(*get_policy_command(client, args))

            elif command == 'core-get-endpoint-device-control-violations':
                return_outputs(*get_endpoint_device_control_violations_command(client, args))

            elif command == 'core-retrieve-files':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-retrieve-files",
                                                   command_function=retrieve_files_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-retrieve-file-details':
                return_entry, file_results = retrieve_file_details_command(client, args)
                demisto.results(return_entry)
                if file_results:
                    demisto.results(file_results)

            elif command == 'core-get-scripts':
                return_outputs(*get_scripts_command(client, args))

            elif command == 'core-get-script-metadata':
                return_outputs(*get_script_metadata_command(client, args))

            elif command == 'core-get-script-code':
                return_outputs(*get_script_code_command(client, args))

            elif command == 'core-action-status-get':
                return_results(action_status_get_command(client, args))

            elif command == 'core-run-script':
                return_results(run_script_command(client, args))

            elif command == 'core-run-snippet-code-script':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-run-snippet-code-script",
                                                   command_function=run_snippet_code_script_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-get-script-execution-status':
                return_results(get_script_execution_status_command(client, args))

            elif command == 'core-get-script-execution-results':
                return_results(get_script_execution_results_command(client, args))

            elif command == 'core-get-script-execution-result-files':
                return_results(get_script_execution_result_files_command(client, args))

            elif command == 'core-run-script-execute-commands':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-run-script-execute-commands",
                                                   command_function=run_script_execute_commands_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-run-script-delete-file':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-run-script-delete-file",
                                                   command_function=run_script_delete_file_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-run-script-file-exists':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-run-script-file-exists",
                                                   command_function=run_script_file_exists_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'core-run-script-kill-process':
                return_results(run_polling_command(client=client,
                                                   args=args,
                                                   cmd="core-run-script-kill-process",
                                                   command_function=run_script_kill_process_command,
                                                   command_decision_field="action_id",
                                                   results_function=action_status_get_command,
                                                   polling_field="status",
                                                   polling_value=["PENDING",
                                                                  "IN_PROGRESS",
                                                                  "PENDING_ABORT"]))

            elif command == 'endpoint':
                return_results(endpoint_command(client, args))

            elif command == 'core-report-incorrect-wildfire':
                return_results(report_incorrect_wildfire_command(client, args))

            elif command == 'core-remove-blocklist-files':
                return_results(remove_blocklist_files_command(client, args))

            elif command == 'core-remove-allowlist-files':
                return_results(remove_allowlist_files_command(client, args))

            elif command == 'core-add-exclusion':
                return_results(add_exclusion_command(client, args))

            elif command == 'core-delete-exclusion':
                return_results(delete_exclusion_command(client, args))

            elif command == 'core-get-exclusion':
                return_results(get_exclusion_command(client, args))

        except Exception as err:
            demisto.error(traceback.format_exc())
            return_error(str(err))


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Cortex Core - IR', 'end', __line__())
  subtype: python3
  type: python
  dockerimage: demisto/python3:3.10.1.25933
tests:
- No tests
fromversion: 6.2.0
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAACXBIWXMAAAsSAAALEgHS3X78AAAD6klEQVR4nO2cS24bMQyGyaL75AbJCeo5QIH6BnVPkOkN3BPER8gN4tzA3XQbB+gBHHTbRbzq1kH3ZaGA4ygUNaPxxBOA4AcIqPWgHv9QosZOkYjAscs719Y2LrBxXGDjuMDGcYGN4wIbxwU2jgtsHBfYOC6wcVxg47jAxnGBjeMCG+f9W04PEacAENIDES2TCs7wNR77+2BEPAeABQBcRNl3RDRNKjuDGdWDEbEGgCsAOEkKnaPQW2BErHhbPY2ydwCwJqJN0uCluNdJQf/+Q79VUiAgonWS+WyjEuMvIRwjDwPs7OL14eMpJrGfm2+YGyLOAeAPAPwloh9Jb1HlogQAQaAwAGpJD5otfiC0dksuW/LnYH+u2SiwpaVg91SxsVbqdqXFQDtr0bYW5cFJKlEniLsR9eZc9hsA/gHAL22d9ja0TKWT4olkbMgHYxNPhs9kWZ4Ic4DAT7YUG28ucMm8owd/7xBR2UdOH7R1alLJFh06+STybnhyQbhz3kJmAHCmbDG1yH8MdbXtKGICACsWs4tvvDDNw1ixdzR9TsJ2KLbsJY8/5jL6951Snt3ymS3bzZHMl4gWHHQ2Aed+3ogoA9EbIqqjtj8z/SSdZBMvVvwEPQnaUn+m5MmnUPME+SQ3aarUlR5cUifpU2nTq77iwYmH9jj+5BrJneFg210ePBOf6zbPI6JVkpl64VVSI8+swHM0kgBGqfPanLPXSTrv+MEzOWCbcFa8Y94rOhTTK4pui0xbeLFtE9EuXzWhM1oODwwixjYrcQ175G3v2JyJbb7hrmPrbpjyUSOPs2nPNXtBL4FDyD6ksyMxaTE7eIFGRIthTnjHqw8dRte7aLkw86RGN9u4BgcVpWTv1RH37CVbkf+d44USG69BeBuHSuoMFDveEVxw+UF0CbxkL2i4DOcMX77jAZ6GQSCidtbJbb3PYEu21jkvYsViN3wecnaNBSLOhLhhvb+Idb8+WGQt8hIRnryQxxH1Wl7EC9vLC70WRa8y48lG0XxN2rX1lUuvEEUfcg+uxHj3LzuUMuIgNxlHW2otFCLJztSUaS9fdOyEMFLgdY8XHdPSRWtLYwusjDN5GBXnKJpLn2tS4+VLRFxxhzMlUt3yZHNRdmh3G30ObW8RsYkwm3M5bLFXHdeKHZ+58ed4rBt+zxtfxxYF23VsUztqNPqc77LuQuQtZbzA6w7iWAtHZF0aOI72dWFHIOFfFx6J0X7RwV75VQQPjhWB4Vnkit9lOyPwpn/h7z/ZOT7+XzgYx39VaRwX2DgusHFcYOO4wMZxgY3jAhvHBTaOC2wcF9g4LrBxXGDjuMDGcYEtAwD/AbjPSozwVJX9AAAAAElFTkSuQmCC
detaileddescription: '[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/cortex-core---ir)'
